{"version":3,"file":"editform.min.js","sources":["../src/editform.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Helper functions for the form used to create / edit a formulas question.\n *\n * @module     qtype_formulas/editform\n * @copyright  2022 Philipp Imhof\n * @author     Philipp Imhof\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport * as Notification from 'core/notification';\nimport Pending from 'core/pending';\nimport {call as fetchMany} from 'core/ajax';\nimport * as Instantiation from 'qtype_formulas/instantiation';\n\n/**\n * Default grading criterion according to plugin settings (admin)\n */\nvar defaultCorrectness = '';\n\n/**\n * Number of subquestions (parts)\n */\nvar numberOfParts = 0;\n\nexport const init = (defCorrectness) => {\n    defaultCorrectness = defCorrectness;\n    numberOfParts = document.querySelectorAll('fieldset[id^=id_answerhdr_]').length;\n\n    Instantiation.init(numberOfParts);\n\n    for (let i = 0; i < numberOfParts; i++) {\n        let textfield = document.getElementById(`id_correctness_${i}`);\n\n        // Event listener for the submission of the form (attach only once)\n        if (i === 0) {\n            textfield.form.addEventListener('submit', reenableCriterionTextfields);\n        }\n\n        // Constantly check whether the current grading criterion is simple enough\n        // to allow to switch to simple mode.\n        textfield.addEventListener('input', blockModeSwitcherIfNeeded.bind(null, i));\n\n        let checkbox = document.getElementById(`id_correctness_simple_mode_${i}`);\n        checkbox.addEventListener('click', handleGradingCriterionModeSwitcher.bind(null, i));\n        checkbox.addEventListener('change', handleGradingCriterionModeSwitcher.bind(null, i));\n\n        // Trigger input event in criterion textfields in order to disable the mode switcher\n        // checkbox, if needed. If the criterion is simple enough, start with simple mode,\n        // unless the form comes back from validation and the textfield is marked as invalid.\n        textfield.dispatchEvent(new Event('input'));\n        if (!checkbox.disabled && !textfield.classList.contains('is-invalid')) {\n            checkbox.checked = true;\n            checkbox.dispatchEvent(new Event('click'));\n        }\n\n        // Always keep the textual form of the grading criterion in sync, because that's\n        // what is going to be submitted in the end.\n        let elements = ['type', 'comp', 'tol'];\n        for (let element of elements) {\n            document.getElementById(`id_correctness_simple_${element}_${i}`).addEventListener(\n                'change', handleSimpleCriterionChanges.bind(null, i)\n            );\n        }\n        document.getElementById(`id_correctness_simple_tol_${i}`).addEventListener(\n            'change', normalizeTolerance\n        );\n    }\n\n    // When the form fields for random, global or any part's local variables loses focus,\n    // have them validated by the backend. We don't use the 'change' event, because we want\n    // the content re-validated, even if there is no change. This is to capture some edge\n    // cases where there is an error in both random and global variables. The validation will\n    // fail for random and cannot check the globals. Now, if the user fixes the error in random\n    // and enters globals, we should have a new validation on blurring, even if there was no change.\n    let variableFields = [{field: 'random', handler: validateRandomvars}, {field: 'global', handler: validateGlobalvars}];\n    for (let i = 0; i < numberOfParts; i++) {\n        variableFields.push({field: `1_${i}`, handler: validateLocalvars.bind(null, i)});\n    }\n    for (let field of variableFields) {\n        document.getElementById(`id_vars${field.field}`).addEventListener(\n            'blur', field.handler\n        );\n    }\n\n    // Event listener for the \"instantiate\" button.\n    document.getElementById('id_instantiatebtn').addEventListener(\n        'click', Instantiation.instantiate\n    );\n\n    // We want to disable the simplified mode for all grading criterions where the validation\n    // has found an error. If the document has finished loading (readyState is 'interactive'\n    // or 'complete'), we can access all DOM elements, so we proceed. Otherwise, we attach the\n    // corresponding method to the DOMContentLoaded event.\n    if (document.readyState !== 'loading') {\n        disableSimpleModeIfError();\n    } else {\n        document.addEventListener('DOMContentLoaded', disableSimpleModeIfError.bind(null));\n    }\n};\n\n/**\n * For all parts, check whether there has been an evaluation error of the grading\n * criterion. If yes, we should not enter simplified mode, because the error message\n * will not be visible.\n */\nconst disableSimpleModeIfError = () => {\n    for (let i = 0; i < numberOfParts; i++) {\n        if (document.getElementById(`id_error_correctness_${i}`).innerText.trim() !== '') {\n            document.getElementById(`id_correctness_simple_mode_${i}`).checked = false;\n        }\n    }\n};\n\n/**\n * Event handler for the global variables definition. The function will send the text to\n * the backend and try to evaluate it (together with the random variables, because global\n * variables can be based on random variables). If there is an error, it will be shown\n * in the form via {@link showOrClearValidationError}.\n *\n * @param {Event} evt Event object\n */\nconst validateGlobalvars = async(evt) => {\n    // We don't validate an empty field. But if there is an error from earlier validation,\n    // we must make sure it is removed.\n    if (evt.target.value === '') {\n        showOrClearValidationError(evt.target.id, '');\n        return;\n    }\n    let pendingPromise = new Pending('qtype_formulas/validateglobal');\n    try {\n        let validationResult = await fetchMany([{\n            methodname: 'qtype_formulas_check_random_global_vars',\n            args: {\n                randomvars: document.getElementById('id_varsrandom').value,\n                globalvars: evt.target.value\n            },\n        }])[0];\n        if (validationResult.source === '' || validationResult.source === 'global') {\n            showOrClearValidationError(evt.target.id, validationResult.message);\n        } else {\n            showOrClearValidationError('id_varsrandom', validationResult.message, false);\n        }\n    } catch (err) {\n        Notification.exception(err);\n    }\n    pendingPromise.resolve();\n};\n\n/**\n * Event handler for the random variables definition. The function will send the text to\n * the backend which tries to parse it and instantiate the variables. If there is an error,\n * it will be shown in the form via {@link showOrClearValidationError}.\n *\n * @param {Event} evt Event object\n */\nconst validateRandomvars = async(evt) => {\n    // We don't validate an empty field. But if there is an error from earlier validation,\n    // we must make sure it is removed.\n    if (evt.target.value === '') {\n        showOrClearValidationError(evt.target.id, '');\n        return;\n    }\n    let pendingPromise = new Pending('qtype_formulas/validaterandom');\n    try {\n        let validationResult = await fetchMany([{\n            methodname: 'qtype_formulas_check_random_global_vars',\n            args: {\n                randomvars: evt.target.value\n            },\n        }])[0];\n        showOrClearValidationError(evt.target.id, validationResult.message);\n    } catch (err) {\n        Notification.exception(err);\n    }\n    pendingPromise.resolve();\n};\n\nconst validateLocalvars = async(part) => {\n    let fieldList = {\n        'random': 'id_varsrandom',\n        'global': 'id_varsglobal',\n        'local': `id_vars1_${part}`\n    };\n    let target = document.getElementById(fieldList.local);\n    // We don't validate an empty field. But if there is an error from earlier validation,\n    // we must make sure it is removed.\n    if (target.value === '') {\n        showOrClearValidationError(target.id, '');\n        return;\n    }\n    let pendingPromise = new Pending('qtype_formulas/validatelocal');\n    try {\n        let validationResult = await fetchMany([{\n            methodname: 'qtype_formulas_check_local_vars',\n            args: {\n                randomvars: document.getElementById(fieldList.random).value,\n                globalvars: document.getElementById(fieldList.global).value,\n                localvars: target.value\n            }\n        }])[0];\n        if (validationResult.source === '') {\n            validationResult.source = 'local';\n        }\n        showOrClearValidationError(\n            fieldList[validationResult.source],\n            validationResult.message,\n            validationResult.source === 'local'\n        );\n    } catch (err) {\n        Notification.exception(err);\n    }\n    pendingPromise.resolve();\n};\n\n/**\n * Show a validation error below the corresponding form field and set the field\n * as invalid. Or remove message and marking, if there is no error anymore.\n *\n * @param {string} fieldID id of the form field to which the error belongs\n * @param {string} message error message or empty string, if error is to be removed\n * @param {boolean} sameField did the error occur in the field that was originally validated\n */\nconst showOrClearValidationError = (fieldID, message, sameField = true) => {\n    let field = document.getElementById(fieldID);\n    let annotation = document.getElementById(fieldID.replace(/^id_(.*)$/, 'id_error_$1'));\n    let alreadyWithError = (annotation.innerText.trim() !== '');\n    if (message === '') {\n        annotation.innerText = '';\n        field.classList.remove('is-invalid');\n        return;\n    }\n    // If row and column number are -1, we remove them.\n    annotation.innerText = message.replaceAll('-1:', '');\n    field.classList.add('is-invalid');\n    // If there is already an error in *this* field, we don't generally force the focus,\n    // because that could trap the user. We do, however, set the focus, if the prior error\n    // occured in another field.\n    if (!alreadyWithError || !sameField) {\n        // We set the focus here, so we don't depend on the further processing.\n        field.focus();\n\n        // If we have a row and column number, extract them and place the cursor accordingly.\n        let messageParts = message.split(':', 2);\n        if (messageParts.length < 2) {\n            return;\n        }\n        let row = parseInt(messageParts[0]);\n        let col = parseInt(messageParts[1]);\n        jumpToRowAndColumn(field, row, col);\n    }\n};\n\nconst jumpToRowAndColumn = (field, row, col) => {\n    let lines = field.value.split('\\n');\n\n    // If the row number is invalid, we leave. Focus has already been set by the caller.\n    if (row == -1 || col == -1) {\n        return;\n    }\n\n    let cursorPosition = 0;\n    // First, for every line, advance the appropriate number of characters.\n    for (let i = 0; i < row - 1; i++) {\n        // Stop if the row number is too high. This will bring us to the end of the field.\n        if (i >= lines.length) {\n            break;\n        }\n        cursorPosition += lines[i].length + 1;\n    }\n    // Now shift the cursor (col - 1) characters to the right, but not more than the line's length.\n    // Also avoid shifting it to the left, in case col is 0.\n    cursorPosition += Math.max(0, Math.min(col - 1, lines[row - 1].length));\n    field.focus();\n    field.setSelectionRange(cursorPosition, cursorPosition);\n};\n\n/**\n * The textfields containing the grading criterion might be disabled. However, as disabled elements\n * do not submit their value, they have to be enabled before submitting the form.\n */\nconst reenableCriterionTextfields = () => {\n    for (let i = 0; i < numberOfParts; i++) {\n        document.getElementById(`id_correctness_${i}`).disabled = false;\n    }\n};\n\n/**\n * Handle change event for the elements that allow simplified entry of the grading criterion.\n * On each modification, the current criterion is propagated to the (hidden) textbox,\n * that will be used to store the criterion in the database upon submission of the form.\n * @param {number} partNumber number of the part\n */\nconst handleSimpleCriterionChanges = (partNumber) => {\n    let textbox = document.getElementById(`id_correctness_${partNumber}`);\n    textbox.value = convertSimpleCriterionToText(partNumber);\n};\n\n/**\n * Parse the tolerance value into a number and put the value back into the textfield.\n * This allows for immediate simplification and some validation; invalid numbers will be replaced by 0.\n * @param {Event} event Event containing the textfield to be normalized\n */\nconst normalizeTolerance = (event) => {\n    let field = event.target;\n    let tolerance = parseFloat(field.value);\n\n    if (isNaN(tolerance) || !isFinite(tolerance)) {\n        tolerance = 0;\n    }\n\n    field.value = tolerance;\n};\n\n/**\n * Switch between simplified and normal entry mode for the grading criterion.\n * @param {number} partNumber number of the part\n */\nconst handleGradingCriterionModeSwitcher = (partNumber) => {\n    let checkbox = document.getElementById(`id_correctness_simple_mode_${partNumber}`);\n\n    let criterionTextfield = document.getElementById(`id_correctness_${partNumber}`);\n\n    // If not checked anymore, activate expert mode --> convert settings to string and set textfield.\n    if (!checkbox.checked) {\n        criterionTextfield.value = convertSimpleCriterionToText(partNumber);\n        return;\n    }\n\n    // Activate simple mode. If input field is empty, use default value.\n    if (criterionTextfield.value.trim() == '') {\n        criterionTextfield.value = defaultCorrectness;\n    }\n\n    let simpleCriterion = convertTextCriterionToSimple(partNumber);\n    document.getElementById(`id_correctness_simple_type_${partNumber}`).value = simpleCriterion.type;\n    document.getElementById(`id_correctness_simple_comp_${partNumber}`).value = simpleCriterion.comparison;\n    document.getElementById(`id_correctness_simple_tol_${partNumber}`).value = simpleCriterion.tolerance;\n};\n\n/**\n * Convert the simple grading criterion into the corresponding text.\n * @param {number} partNumber number of the part\n * @returns {string} text form of the grading criterion\n */\nconst convertSimpleCriterionToText = (partNumber) => {\n    let typeElement = document.getElementById(`id_correctness_simple_type_${partNumber}`);\n    let comparisonElement = document.getElementById(`id_correctness_simple_comp_${partNumber}`);\n    let toleranceElement = document.getElementById(`id_correctness_simple_tol_${partNumber}`);\n\n    return ['_relerr', '_err'][typeElement.value] + ' '\n        + comparisonElement.options[comparisonElement.value].innerText + ' '\n        + parseFloat(toleranceElement.value);\n};\n\n/**\n * Convert the grading criterion into the simplified form.\n * @param {number} partNumber number of the part\n * @returns {object} criterion the simplified grading criterion\n * @returns {number} criterion.type the type of error (relative or absolute)\n * @returns {number} criterion.comparison the comparison (== or <)\n * @returns {number} criteron.tolerance the tolerance value\n * @throws {TypeError} throws if the value cannot be converted\n */\nconst convertTextCriterionToSimple = (partNumber) => {\n    // Split input into its parts (type, comparison, tolerance).\n    let criterionParts = document.getElementById(`id_correctness_${partNumber}`).value.split(/\\s*(==|<)\\s*/);\n\n    // This should not happen, but it might be better to check anyway.\n    if (criterionParts.length != 3 || !criterionParts[0].match(/^\\s*_(rel)?err\\s*$/)) {\n        throw new TypeError('The given grading criterion cannot be shown in simple mode.');\n    }\n\n    return {\n        'type': ['_relerr', '_err'].indexOf(criterionParts[0]),\n        'comparison': ['==', '<'].indexOf(criterionParts[1]),\n        'tolerance': parseFloat(criterionParts[2])\n    };\n};\n\n/**\n * Check whether the current grading criterion can be converted into the simplified form.\n * If not, disable the checkbox that would allow switching to simple mode.\n * If yes, enable sais checkbox.\n * If the text box is empty, conversion is possible using the default value.\n * @param {number} partNumber number of the part\n */\nconst blockModeSwitcherIfNeeded = (partNumber) => {\n    let criterion = document.getElementById(`id_correctness_${partNumber}`).value.trim();\n    let modeCheckbox = document.getElementById(`id_correctness_simple_mode_${partNumber}`);\n    // If textfield is empty, allow conversion to easy mode\n    if (criterion == '') {\n        modeCheckbox.disabled = false;\n        return;\n    }\n\n    // Value must have exactly three parts: type + comparison + tolerance (number).\n    let criterionParts = criterion.split(/\\s*(==|<)\\s*/);\n    if (criterionParts.length != 3) {\n        modeCheckbox.disabled = true;\n        return;\n    }\n\n    // Type must be _relerr or _err.\n    if (!criterionParts[0].match(/^\\s*_(rel)?err\\s*$/)) {\n        modeCheckbox.disabled = true;\n        return;\n    }\n\n    // Comparison must be == or <.\n    if (!criterionParts[1].match(/\\s*(==|<)\\s*$/)) {\n        modeCheckbox.disabled = true;\n        return;\n    }\n\n    // Tolerance must be a number.\n    let tolerance = parseFloat(criterionParts[2]);\n    // As parseFloat ignores trailing characters, we check for that separately;\n    // we just don't want the tolerance number to contain obviously invalid characters.\n    if (isNaN(tolerance) || !isFinite(tolerance) || criterionParts[2].match(/[^-+0-9.e]/)) {\n        modeCheckbox.disabled = true;\n        return;\n    }\n\n    modeCheckbox.disabled = false;\n};\n\nexport default {init};\n"],"names":["defaultCorrectness","numberOfParts","init","defCorrectness","document","querySelectorAll","length","Instantiation","i","textfield","getElementById","form","addEventListener","reenableCriterionTextfields","blockModeSwitcherIfNeeded","bind","checkbox","handleGradingCriterionModeSwitcher","dispatchEvent","Event","disabled","classList","contains","checked","elements","element","handleSimpleCriterionChanges","normalizeTolerance","variableFields","field","handler","validateRandomvars","validateGlobalvars","push","validateLocalvars","instantiate","readyState","disableSimpleModeIfError","innerText","trim","async","evt","target","value","showOrClearValidationError","id","pendingPromise","Pending","validationResult","methodname","args","randomvars","globalvars","source","message","err","Notification","exception","resolve","fieldList","part","local","random","global","localvars","fieldID","sameField","annotation","replace","alreadyWithError","remove","replaceAll","add","focus","messageParts","split","row","parseInt","col","jumpToRowAndColumn","lines","cursorPosition","Math","max","min","setSelectionRange","partNumber","convertSimpleCriterionToText","event","tolerance","parseFloat","isNaN","isFinite","criterionTextfield","simpleCriterion","convertTextCriterionToSimple","type","comparison","typeElement","comparisonElement","toleranceElement","options","criterionParts","match","TypeError","indexOf","criterion","modeCheckbox"],"mappings":"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"}