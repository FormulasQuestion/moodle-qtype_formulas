{"version":3,"file":"editform.min.js","sources":["../src/editform.js"],"sourcesContent":["// This file is part of Moodle - https://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <https://www.gnu.org/licenses/>.\n\n/**\n * Helper functions for the form used to create / edit a formulas question.\n *\n * @module     qtype_formulas/editform\n * @copyright  2022 Philipp Imhof\n * @author     Philipp Imhof\n * @license    https://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport * as Notification from 'core/notification';\nimport Pending from 'core/pending';\nimport {call as fetchMany} from 'core/ajax';\nimport * as Instantiation from 'qtype_formulas/instantiation';\nimport * as String from 'core/str';\n\n/**\n * Default grading criterion according to plugin settings (admin)\n */\nvar defaultCorrectness = '';\n\n/**\n * Number of subquestions (parts)\n */\nvar numberOfParts = 0;\n\n/**\n * Pending timer, allowing to reset / cancel it.\n */\nvar timer = null;\n\n/**\n * Delay (in milliseconds) before sending the current input of a field to validation.\n */\nconst DELAY = 250;\n\n/**\n * Warning text for use of caret in model answer.\n */\nvar caretWarning = '';\n\n/**\n * Initialization, i. e. registration of event handlers and stuff.\n *\n * @param {string} defCorrectness default correctness criterion from admin settings\n */\nexport const init = (defCorrectness) => {\n    defaultCorrectness = defCorrectness;\n    numberOfParts = document.querySelectorAll(\"fieldset[id^='id_answerhdr_']\").length;\n\n    Instantiation.init(numberOfParts);\n\n    // Pre-fetch strings; currently there is only one.\n    fetchStrings();\n\n    for (let i = 0; i < numberOfParts; i++) {\n        let textfield = document.getElementById(`id_correctness_${i}`);\n\n        // Event listener for the submission of the form (attach only once)\n        if (i === 0) {\n            textfield.form.addEventListener('submit', reenableCriterionTextfields);\n        }\n\n        // Constantly check whether the current grading criterion is simple enough\n        // to allow to switch to simple mode.\n        textfield.addEventListener('input', blockModeSwitcherIfNeeded.bind(null, i));\n\n        let checkbox = document.getElementById(`id_correctness_simple_mode_${i}`);\n        checkbox.addEventListener('click', handleGradingCriterionModeSwitcher.bind(null, i));\n        checkbox.addEventListener('change', handleGradingCriterionModeSwitcher.bind(null, i));\n\n        // Trigger input event in criterion textfields in order to disable the mode switcher\n        // checkbox, if needed. If the criterion is simple enough, start with simple mode,\n        // unless the form comes back from validation and the textfield is marked as invalid.\n        textfield.dispatchEvent(new Event('input'));\n        if (!checkbox.disabled && !textfield.classList.contains('is-invalid')) {\n            checkbox.checked = true;\n            checkbox.dispatchEvent(new Event('click'));\n        }\n\n        // Always keep the textual form of the grading criterion in sync, because that's\n        // what is going to be submitted in the end.\n        let elements = ['type', 'comp', 'tol'];\n        for (let element of elements) {\n            document.getElementById(`id_correctness_simple_${element}_${i}`).addEventListener(\n                'change', handleSimpleCriterionChanges.bind(null, i)\n            );\n        }\n        document.getElementById(`id_correctness_simple_tol_${i}`).addEventListener(\n            'change', normalizeTolerance\n        );\n\n        // Attach listener for input event to answer fields.\n        document.getElementById(`id_answer_${i}`).addEventListener('input', setDebounceTimer);\n    }\n\n    // When the form fields for random, global or any part's local variables loses focus,\n    // have them validated by the backend. We don't use the 'change' event, because we want\n    // the content re-validated, even if there is no change. This is to capture some edge\n    // cases where there is an error in both random and global variables. The validation will\n    // fail for random and cannot check the globals. Now, if the user fixes the error in random\n    // and enters globals, we should have a new validation on blurring, even if there was no change.\n    let variableFields = [{field: 'random', handler: validateRandomvars}, {field: 'global', handler: validateGlobalvars}];\n    for (let i = 0; i < numberOfParts; i++) {\n        variableFields.push({field: `1_${i}`, handler: validateLocalvars.bind(null, i)});\n    }\n    for (let field of variableFields) {\n        document.getElementById(`id_vars${field.field}`).addEventListener(\n            'blur', field.handler\n        );\n    }\n\n    // Event listener for the \"instantiate\" button.\n    document.getElementById('id_instantiatebtn').addEventListener(\n        'click', Instantiation.instantiate\n    );\n\n    // We want to disable the simplified mode for all grading criterions where the validation\n    // has found an error. If the document has finished loading (readyState is 'interactive'\n    // or 'complete'), we can access all DOM elements, so we proceed. Otherwise, we attach the\n    // corresponding method to the DOMContentLoaded event.\n    if (document.readyState !== 'loading') {\n        disableSimpleModeIfError();\n    } else {\n        document.addEventListener('DOMContentLoaded', disableSimpleModeIfError.bind(null));\n    }\n};\n\n/**\n * Pre-fetch strings from the language file.\n */\nconst fetchStrings = async() => {\n    let pendingPromise = new Pending('qtype_formulas/editformstrings');\n    let strings = null;\n    try {\n        strings = await String.get_strings([\n            {key: 'caretwarning', component: 'qtype_formulas'},\n        ]);\n    } catch (err) {\n        Notification.exception(err);\n    }\n    pendingPromise.resolve();\n    // If fetching of strings was not successful, we quit here.\n    if (strings === null) {\n        return;\n    }\n    caretWarning = strings[0];\n};\n\n/**\n * Event handler: set or re-initialize timer for a given input field.\n *\n * @param {Event} evt event\n */\nconst setDebounceTimer = (evt) => {\n    // If a timer has already been set, delete it.\n    if (typeof timer === 'number') {\n        clearTimeout(timer);\n    }\n    // Set timer for given input field.\n    timer = setTimeout(warnAboutCaret, DELAY, evt.target.id);\n};\n\n/**\n * For all parts, check whether there has been an evaluation error of the grading\n * criterion. If yes, we should not enter simplified mode, because the error message\n * will not be visible.\n */\nconst disableSimpleModeIfError = () => {\n    for (let i = 0; i < numberOfParts; i++) {\n        if (document.getElementById(`id_error_correctness_${i}`).innerText.trim() !== '') {\n            document.getElementById(`id_correctness_simple_mode_${i}`).checked = false;\n        }\n    }\n};\n\n/**\n * Event handler for the global variables definition. The function will send the text to\n * the backend and try to evaluate it (together with the random variables, because global\n * variables can be based on random variables). If there is an error, it will be shown\n * in the form via {@link showOrClearValidationError}.\n *\n * @param {Event} evt Event object\n */\nconst validateGlobalvars = async(evt) => {\n    // We don't validate an empty field. But if there is an error from earlier validation,\n    // we must make sure it is removed.\n    if (evt.target.value === '') {\n        showOrClearValidationError(evt.target.id, '');\n        return;\n    }\n    let pendingPromise = new Pending('qtype_formulas/validateglobal');\n    try {\n        let validationResult = await fetchMany([{\n            methodname: 'qtype_formulas_check_random_global_vars',\n            args: {\n                randomvars: document.getElementById('id_varsrandom').value,\n                globalvars: evt.target.value\n            },\n        }])[0];\n        if (validationResult.source === '' || validationResult.source === 'global') {\n            showOrClearValidationError(evt.target.id, validationResult.message);\n        } else {\n            showOrClearValidationError('id_varsrandom', validationResult.message, false);\n        }\n    } catch (err) {\n        Notification.exception(err);\n    }\n    pendingPromise.resolve();\n};\n\n/**\n * Event handler for the random variables definition. The function will send the text to\n * the backend which tries to parse it and instantiate the variables. If there is an error,\n * it will be shown in the form via {@link showOrClearValidationError}.\n *\n * @param {Event} evt Event object\n */\nconst validateRandomvars = async(evt) => {\n    // We don't validate an empty field. But if there is an error from earlier validation,\n    // we must make sure it is removed.\n    if (evt.target.value === '') {\n        showOrClearValidationError(evt.target.id, '');\n        return;\n    }\n    let pendingPromise = new Pending('qtype_formulas/validaterandom');\n    try {\n        let validationResult = await fetchMany([{\n            methodname: 'qtype_formulas_check_random_global_vars',\n            args: {\n                randomvars: evt.target.value\n            },\n        }])[0];\n        showOrClearValidationError(evt.target.id, validationResult.message);\n    } catch (err) {\n        Notification.exception(err);\n    }\n    pendingPromise.resolve();\n};\n\n/**\n * Send text from local variables to web service for validation.\n *\n * @param {number} part number of part\n */\nconst validateLocalvars = async(part) => {\n    let fieldList = {\n        'random': 'id_varsrandom',\n        'global': 'id_varsglobal',\n        'local': `id_vars1_${part}`\n    };\n    let target = document.getElementById(fieldList.local);\n    // We don't validate an empty field. But if there is an error from earlier validation,\n    // we must make sure it is removed.\n    if (target.value === '') {\n        showOrClearValidationError(target.id, '');\n        return;\n    }\n    let pendingPromise = new Pending('qtype_formulas/validatelocal');\n    try {\n        let validationResult = await fetchMany([{\n            methodname: 'qtype_formulas_check_local_vars',\n            args: {\n                randomvars: document.getElementById(fieldList.random).value,\n                globalvars: document.getElementById(fieldList.global).value,\n                localvars: target.value\n            }\n        }])[0];\n        if (validationResult.source === '') {\n            validationResult.source = 'local';\n        }\n        showOrClearValidationError(\n            fieldList[validationResult.source],\n            validationResult.message,\n            validationResult.source === 'local'\n        );\n    } catch (err) {\n        Notification.exception(err);\n    }\n    pendingPromise.resolve();\n};\n\n/**\n * Show a validation error below the corresponding form field and set the field\n * as invalid. Or remove message and marking, if there is no error anymore.\n *\n * @param {string} fieldID id of the form field to which the error belongs\n * @param {string} message error message or empty string, if error is to be removed\n * @param {boolean} sameField did the error occur in the field that was originally validated\n */\nconst showOrClearValidationError = (fieldID, message, sameField = true) => {\n    let field = document.getElementById(fieldID);\n    let annotation = document.getElementById(fieldID.replace(/^id_(.*)$/, 'id_error_$1'));\n    let alreadyWithError = (annotation.innerText.trim() !== '');\n    if (message === '') {\n        annotation.innerText = '';\n        field.classList.remove('is-invalid');\n        return;\n    }\n    // If row and column number are -1, we remove them.\n    annotation.innerText = message.replaceAll('-1:', '');\n    field.classList.add('is-invalid');\n    // If there is already an error in *this* field, we don't generally force the focus,\n    // because that could trap the user. We do, however, set the focus, if the prior error\n    // occured in another field.\n    if (!alreadyWithError || !sameField) {\n        // We set the focus here, so we don't depend on the further processing.\n        field.focus();\n\n        // If we have a row and column number, extract them and place the cursor accordingly.\n        let messageParts = message.split(':', 2);\n        if (messageParts.length < 2) {\n            return;\n        }\n        let row = parseInt(messageParts[0]);\n        let col = parseInt(messageParts[1]);\n        jumpToRowAndColumn(field, row, col);\n    }\n};\n\n/**\n * Show a notice about the meaning of the caret (^) symbol in model answers.\n *\n * @param {string} id the answer field's id\n */\nconst warnAboutCaret = (id) => {\n    // If the string could not be loaded, we quit.\n    if (caretWarning === '') {\n        return;\n    }\n\n    let field = document.getElementById(id);\n    let annotation = document.getElementById(id.replace(/^id_(.*)$/, 'id_error_$1'));\n\n    // Display or hide the notice, depending on the presence of a caret in the model answer.\n    // Also, we make sure not to overwrite or hide existing error messages, e. g. from the\n    // form validation.\n    if (field.value.includes('^')) {\n        if (annotation.innerText.trim() !== '') {\n            return;\n        }\n        annotation.innerText = caretWarning;\n        annotation.style.display = 'block';\n    } else {\n        if (annotation.innerText !== caretWarning) {\n            return;\n        }\n        annotation.innerText = '';\n        annotation.style.display = '';\n    }\n};\n\n/**\n * Jump to a certain text position (row, column) in a textarea field.\n *\n * @param {HTMLElement} field\n * @param {number} row the row\n * @param {number} col the column\n * @returns\n */\nconst jumpToRowAndColumn = (field, row, col) => {\n    let lines = field.value.split('\\n');\n\n    // If the row number is invalid, we leave. Focus has already been set by the caller.\n    if (row == -1 || col == -1) {\n        return;\n    }\n\n    let cursorPosition = 0;\n    // First, for every line, advance the appropriate number of characters.\n    for (let i = 0; i < row - 1; i++) {\n        // Stop if the row number is too high. This will bring us to the end of the field.\n        if (i >= lines.length) {\n            break;\n        }\n        cursorPosition += lines[i].length + 1;\n    }\n    // Now shift the cursor (col - 1) characters to the right, but not more than the line's length.\n    // Also avoid shifting it to the left, in case col is 0.\n    cursorPosition += Math.max(0, Math.min(col - 1, lines[row - 1].length));\n    field.focus();\n    field.setSelectionRange(cursorPosition, cursorPosition);\n};\n\n/**\n * The textfields containing the grading criterion might be disabled. However, as disabled elements\n * do not submit their value, they have to be enabled before submitting the form.\n */\nconst reenableCriterionTextfields = () => {\n    for (let i = 0; i < numberOfParts; i++) {\n        document.getElementById(`id_correctness_${i}`).disabled = false;\n    }\n};\n\n/**\n * Handle change event for the elements that allow simplified entry of the grading criterion.\n * On each modification, the current criterion is propagated to the (hidden) textbox,\n * that will be used to store the criterion in the database upon submission of the form.\n *\n * @param {number} partNumber number of the part\n */\nconst handleSimpleCriterionChanges = (partNumber) => {\n    let textbox = document.getElementById(`id_correctness_${partNumber}`);\n    textbox.value = convertSimpleCriterionToText(partNumber);\n};\n\n/**\n * Parse the tolerance value into a number and put the value back into the textfield.\n * This allows for immediate simplification and some validation; invalid numbers will be replaced by 0.\n *\n * @param {Event} event Event containing the textfield to be normalized\n */\nconst normalizeTolerance = (event) => {\n    let field = event.target;\n    let tolerance = parseFloat(field.value);\n\n    if (isNaN(tolerance) || !isFinite(tolerance)) {\n        tolerance = 0;\n    }\n\n    field.value = tolerance;\n};\n\n/**\n * Switch between simplified and normal entry mode for the grading criterion.\n *\n * @param {number} partNumber number of the part\n */\nconst handleGradingCriterionModeSwitcher = (partNumber) => {\n    let checkbox = document.getElementById(`id_correctness_simple_mode_${partNumber}`);\n\n    let criterionTextfield = document.getElementById(`id_correctness_${partNumber}`);\n\n    // If not checked anymore, activate expert mode --> convert settings to string and set textfield.\n    if (!checkbox.checked) {\n        criterionTextfield.value = convertSimpleCriterionToText(partNumber);\n        return;\n    }\n\n    // Activate simple mode. If input field is empty, use default value.\n    if (criterionTextfield.value.trim() == '') {\n        criterionTextfield.value = defaultCorrectness;\n    }\n\n    let simpleCriterion = convertTextCriterionToSimple(partNumber);\n    document.getElementById(`id_correctness_simple_type_${partNumber}`).value = simpleCriterion.type;\n    document.getElementById(`id_correctness_simple_comp_${partNumber}`).value = simpleCriterion.comparison;\n    document.getElementById(`id_correctness_simple_tol_${partNumber}`).value = simpleCriterion.tolerance;\n};\n\n/**\n * Convert the simple grading criterion into the corresponding text.\n *\n * @param {number} partNumber number of the part\n * @returns {string} text form of the grading criterion\n */\nconst convertSimpleCriterionToText = (partNumber) => {\n    let typeElement = document.getElementById(`id_correctness_simple_type_${partNumber}`);\n    let comparisonElement = document.getElementById(`id_correctness_simple_comp_${partNumber}`);\n    let toleranceElement = document.getElementById(`id_correctness_simple_tol_${partNumber}`);\n\n    return ['_relerr', '_err'][typeElement.value] + ' '\n        + comparisonElement.options[comparisonElement.value].innerText + ' '\n        + parseFloat(toleranceElement.value);\n};\n\n/**\n * Convert the grading criterion into the simplified form.\n *\n * @param {number} partNumber number of the part\n * @returns {object} criterion the simplified grading criterion\n * @returns {number} criterion.type the type of error (relative or absolute)\n * @returns {number} criterion.comparison the comparison (== or <)\n * @returns {number} criteron.tolerance the tolerance value\n * @throws {TypeError} throws if the value cannot be converted\n */\nconst convertTextCriterionToSimple = (partNumber) => {\n    // Split input into its parts (type, comparison, tolerance).\n    let criterionParts = document.getElementById(`id_correctness_${partNumber}`).value.split(/\\s*(==|<)\\s*/);\n\n    // This should not happen, but it might be better to check anyway.\n    if (criterionParts.length != 3 || !criterionParts[0].match(/^\\s*_(rel)?err\\s*$/)) {\n        throw new TypeError('The given grading criterion cannot be shown in simple mode.');\n    }\n\n    return {\n        'type': ['_relerr', '_err'].indexOf(criterionParts[0]),\n        'comparison': ['==', '<'].indexOf(criterionParts[1]),\n        'tolerance': parseFloat(criterionParts[2])\n    };\n};\n\n/**\n * Check whether the current grading criterion can be converted into the simplified form.\n * If not, disable the checkbox that would allow switching to simple mode.\n * If yes, enable said checkbox.\n * If the text box is empty, conversion is possible using the default value.\n *\n * @param {number} partNumber number of the part\n */\nconst blockModeSwitcherIfNeeded = (partNumber) => {\n    let criterion = document.getElementById(`id_correctness_${partNumber}`).value.trim();\n    let modeCheckbox = document.getElementById(`id_correctness_simple_mode_${partNumber}`);\n    // If textfield is empty, allow conversion to easy mode\n    if (criterion == '') {\n        modeCheckbox.disabled = false;\n        return;\n    }\n\n    // Value must have exactly three parts: type + comparison + tolerance (number).\n    let criterionParts = criterion.split(/\\s*(==|<)\\s*/);\n    if (criterionParts.length != 3) {\n        modeCheckbox.disabled = true;\n        return;\n    }\n\n    // Type must be _relerr or _err.\n    if (!criterionParts[0].match(/^\\s*_(rel)?err\\s*$/)) {\n        modeCheckbox.disabled = true;\n        return;\n    }\n\n    // Comparison must be == or <.\n    if (!criterionParts[1].match(/\\s*(==|<)\\s*$/)) {\n        modeCheckbox.disabled = true;\n        return;\n    }\n\n    // Tolerance must be a number.\n    let tolerance = parseFloat(criterionParts[2]);\n    // As parseFloat ignores trailing characters, we check for that separately;\n    // we just don't want the tolerance number to contain obviously invalid characters.\n    if (isNaN(tolerance) || !isFinite(tolerance) || criterionParts[2].match(/[^-+0-9.e]/)) {\n        modeCheckbox.disabled = true;\n        return;\n    }\n\n    modeCheckbox.disabled = false;\n};\n\nexport default {init};\n"],"names":["defaultCorrectness","numberOfParts","timer","caretWarning","init","defCorrectness","document","querySelectorAll","length","Instantiation","fetchStrings","i","textfield","getElementById","form","addEventListener","reenableCriterionTextfields","blockModeSwitcherIfNeeded","bind","checkbox","handleGradingCriterionModeSwitcher","dispatchEvent","Event","disabled","classList","contains","checked","elements","element","handleSimpleCriterionChanges","normalizeTolerance","setDebounceTimer","variableFields","field","handler","validateRandomvars","validateGlobalvars","push","validateLocalvars","instantiate","readyState","disableSimpleModeIfError","async","pendingPromise","Pending","strings","String","get_strings","key","component","err","Notification","exception","resolve","evt","clearTimeout","setTimeout","warnAboutCaret","target","id","innerText","trim","value","showOrClearValidationError","validationResult","methodname","args","randomvars","globalvars","source","message","fieldList","part","local","random","global","localvars","fieldID","sameField","annotation","replace","alreadyWithError","remove","replaceAll","add","focus","messageParts","split","row","parseInt","col","jumpToRowAndColumn","includes","style","display","lines","cursorPosition","Math","max","min","setSelectionRange","partNumber","convertSimpleCriterionToText","event","tolerance","parseFloat","isNaN","isFinite","criterionTextfield","simpleCriterion","convertTextCriterionToSimple","type","comparison","typeElement","comparisonElement","toleranceElement","options","criterionParts","match","TypeError","indexOf","criterion","modeCheckbox"],"mappings":"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"}