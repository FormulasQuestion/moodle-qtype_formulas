{"version":3,"file":"editform.min.js","sources":["../src/editform.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Helper functions for the form used to create / edit a formulas question.\n *\n * @module     qtype_formulas/editform\n * @copyright  2022 Philipp Imhof\n * @author     Philipp Imhof\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport * as Notification from 'core/notification';\nimport * as String from 'core/str';\nimport Pending from 'core/pending';\nimport {call as fetchMany} from 'core/ajax';\nimport {TabulatorFull as Tabulator} from 'qtype_formulas/tabulator';\n\n/**\n * Default grading criterion according to plugin settings (admin)\n */\nvar defaultCorrectness = '';\n\n/**\n * Number of subquestions (parts)\n */\nvar numberOfParts = 0;\n\nexport const init = (defCorrectness) => {\n    defaultCorrectness = defCorrectness;\n    numberOfParts = document.querySelectorAll('fieldset[id^=id_answerhdr_]').length;\n\n    extendTabulator();\n    initTable();\n\n    for (let i = 0; i < numberOfParts; i++) {\n        let textfield = document.getElementById(`id_correctness_${i}`);\n\n        // Event listener for the submission of the form (attach only once)\n        if (i === 0) {\n            textfield.form.addEventListener('submit', reenableCriterionTextfields);\n        }\n\n        // Constantly check whether the current grading criterion is simple enough\n        // to allow to switch to simple mode.\n        textfield.addEventListener('input', blockModeSwitcherIfNeeded.bind(null, i));\n\n        let checkbox = document.getElementById(`id_correctness_simple_mode_${i}`);\n        checkbox.addEventListener('click', handleGradingCriterionModeSwitcher.bind(null, i));\n\n        // Trigger input event in criterion textfields in order to disable the mode switcher\n        // checkbox, if needed. If the criterion is simple enough, start with simple mode,\n        // unless the form comes back from validation and the textfield is marked as invalid.\n        textfield.dispatchEvent(new Event('input'));\n        if (!checkbox.disabled && !textfield.classList.contains('is-invalid')) {\n            checkbox.checked = true;\n            checkbox.dispatchEvent(new Event('click'));\n        }\n\n        // Always keep the textual form of the grading criterion in sync, because that's\n        // what is going to be submitted in the end.\n        let elements = ['type', 'comp', 'tol'];\n        for (let element of elements) {\n            document.getElementById(`id_correctness_simple_${element}_${i}`).addEventListener(\n                'change', handleSimpleCriterionChanges.bind(null, i)\n            );\n        }\n        document.getElementById(`id_correctness_simple_tol_${i}`).addEventListener(\n            'change', normalizeTolerance\n        );\n    }\n\n    // When the form fields for random, global or any part's local variables loses focus,\n    // have them validated by the backend. We don't use the 'change' event, because we want\n    // the content re-validated, even if there is no change. This is to capture some edge\n    // cases where there is an error in both random and global variables. The validation will\n    // fail for random and cannot check the globals. Now, if the user fixes the error in random\n    // and enters globals, we should have a new validation on blurring, even if there was no change.\n    let variableFields = [{field: 'random', handler: validateRandomvars}, {field: 'global', handler: validateGlobalvars}];\n    for (let i = 0; i < numberOfParts; i++) {\n        variableFields.push({field: `1_${i}`, handler: validateLocalvars.bind(null, i)});\n    }\n    for (let field of variableFields) {\n        document.getElementById(`id_vars${field.field}`).addEventListener(\n            'blur', field.handler\n        );\n    }\n\n    // Event listener for the \"instantiate\" button.\n    document.getElementById('id_instantiatebtn').addEventListener(\n        'click', instantiate\n    );\n};\n\n/**\n * Add some customizations to Tabulator.js\n */\nconst extendTabulator = () => {\n    Tabulator.extendModule('columnCalcs', 'calculations', {\n        'stats': (values) => {\n            var count = 0;\n            var min = Infinity;\n            var max = -Infinity;\n            var sum = 0;\n\n            for (let value of values) {\n                sum += parseFloat(value);\n                min = Math.min(min, value);\n                max = Math.max(max, value);\n                count++;\n            }\n\n            // If minimum and maximum are the same, we don't display the stats, because\n            // the values are constant.\n            if (min === max) {\n                return ['', '', ''];\n            }\n\n            if (count > 0 && !isNaN(sum)) {\n                return [(sum / count).toFixed(1), min, max];\n            }\n            return ['', '', ''];\n        },\n    });\n};\n\n/**\n * Init the table we use for checking the variables' instantiation.\n */\nconst initTable = () => {\n    let table = new Tabulator('#varsdata_display', {\n        selectable: 1,\n        movableColumns: true,\n        pagination: 'local',\n        paginationSize: 10,\n        paginationButtonCount: 0,\n        columns: [\n            {title: '#', field: 'id'},\n        ],\n        langs: {\n            'default': {\n                'pagination': {\n                    'first': '⏮',\n                    'last': '⏭',\n                    'prev': '⏪',\n                    'next': '⏩'\n                }\n            }\n        },\n    });\n    table.on('rowSelected', previewQuestionWithDataset);\n};\n\n/**\n * For proper parsing in the backend, strings must be enclosed in double quotes,\n * but numbers must not.\n *\n * @param {string} value representation of a numberic, string or list (array) value\n * @returns {string} the same value, but with quotes added, if necessary\n */\nconst quoteNonNumericValue = (value) => {\n    // Numbers must not be quoted.\n    if (!isNaN(value)) {\n        return value;\n    }\n    // For arrays, we have to check each element individually and quote, if necessary.\n    // Formulas question does not currently support nested arrays, so we don't have to deal with that.\n    if (value.startsWith('[')) {\n        let quotedElements = [];\n        // Remove leading and trailing bracket\n        value = value.substring(1, value.length - 1);\n        let elements = value.split(/\\s*,\\s*/);\n        for (let element of elements) {\n            quotedElements.push(quoteNonNumericValue(element));\n        }\n        return '[' + quotedElements.join(', ') + ']';\n    }\n    // Not a number and not an array, so we enclose it in double quotes.\n    return `\"${value}\"`;\n};\n\n/**\n * The question text and the parts' text are stored in the editor. For some editors,\n * we can take the content from the textarea's value attribute. For TinyMCE (and maybe others),\n * we must use the corresponding API.\n *\n * @param {string} id id of the textarea\n * @returns {string} the question or part's text\n */\nconst fetchTextFromEditor = (id) => {\n    if (typeof window.tinyMCE !== 'undefined' && window.tinyMCE.get(id) !== null) {\n        return window.tinyMCE.get(id).getContent();\n    }\n    return document.getElementById(id).value;\n};\n\n/**\n * Extract data from the instantiation table (selected row) and send them to the backend,\n * in order to have the question text and parts' text rendered for the preview.\n *\n * @param {object} row RowComponent from Tabulator.js\n */\nconst previewQuestionWithDataset = async(row) => {\n    // The statistics row is clickable, but we cannot use its data to preview the question.\n    if (row.getElement().classList.contains('tabulator-calcs')) {\n        return;\n    }\n    let data = row.getData();\n    let questionvars = '';\n    let partvars = Array(numberOfParts).fill('');\n\n    for (let varname in data) {\n        // Variables for the main question are all random or global.\n        // Also, as random variables have already been instantiated, they are not random anymore.\n        if (varname.match(/^(random|global)_/)) {\n            questionvars += varname.replace(/^(random|global)_([^*]+)\\*?$/, '$2') + '=';\n            questionvars += quoteNonNumericValue(data[varname]) + ';';\n        }\n        // Variables for a question part always start with part_ + number of the part\n        if (varname.match(/^part_(\\d+)_/)) {\n            // If the variable name starts with _ it should be removed, as these are\n            // answers (or otherwise reserved names, but that should not be the case)\n            if (varname.match(/^part_(\\d+)__/)) {\n                continue;\n            }\n            let index = parseInt(varname.replace(/^part_(\\d+)_.*$/, '$1'));\n            partvars[index] += varname.replace(/^part_(\\d+)_([^*]+)\\*?$/, '$2') + '=';\n            partvars[index] += quoteNonNumericValue(data[varname]) + ';';\n        }\n    }\n\n    let parttexts = [];\n    for (let i = 0; i < numberOfParts; i++) {\n        parttexts[i] = fetchTextFromEditor(`id_subqtext_${i}`);\n    }\n\n    let pendingPromise = new Pending('qtype_formulas/questionpreview');\n    try {\n        let renderedTexts = await fetchMany([{\n            methodname: 'qtype_formulas_render_question_text',\n            args: {\n                questiontext: fetchTextFromEditor('id_questiontext'),\n                parttexts: parttexts,\n                globalvars: questionvars,\n                partvars: partvars\n            }\n        }])[0];\n        showRenderedQuestionAndParts(renderedTexts);\n    } catch (err) {\n        Notification.exception(err);\n    }\n    pendingPromise.resolve();\n};\n\n/**\n * Trigger MathJax rendering for the question.\n *\n * @param {Element} element the <div> element where the question text is shown\n */\nconst triggerMathJax = (element) => {\n    if (typeof window.MathJax === 'undefined') {\n        return;\n    }\n    let version = window.MathJax.version;\n    if (version[0] == '2') {\n        window.MathJax.Hub.Queue(['Typeset', window.MathJax.Hub, element]);\n        return;\n    }\n    if (version[0] == '3') {\n        window.MathJax.typesetPromise([element]);\n    }\n};\n\n/**\n * This function is called after the AJAX request to the backend is completed. It will inject\n * the rendered texts into the preview div.\n *\n * @param {object} data rendered version of question text and parts' text\n */\nconst showRenderedQuestionAndParts = (data) => {\n    let div = document.getElementById('qtextpreview_display');\n    div.innerHTML = data.question;\n    for (let text of data.parts) {\n        div.innerHTML += text;\n    }\n    triggerMathJax(div);\n};\n\n/**\n * Derive the column description from the instantiated variables.\n *\n * @param {object} data instantiation data as received from the backend\n */\nconst prepareTableColumns = (data) => {\n    let firstRow = data[0];\n    let calcOptions = {bottomCalc: 'stats', bottomCalcFormatter: (cell) => cell.getValue().join('<br>')};\n    let columnDescription = [{title: '#', field: 'id', bottomCalcFormatter: () => '⌀<br>min</br>max'}];\n\n    // Random variables come first\n    let randomColumns = [];\n    for (let column of firstRow.randomvars) {\n        randomColumns.push({\n            title: column.name,\n            field: `random_${column.name}`,\n            ...calcOptions\n        });\n    }\n    if (randomColumns.length > 0) {\n        columnDescription.push({title: 'Random variables', columns: randomColumns});\n    }\n\n    // Then we take the global variables\n    let globalColumns = [];\n    for (let column of firstRow.globalvars) {\n        globalColumns.push({\n            title: column.name,\n            field: `global_${column.name}`,\n            ...calcOptions\n        });\n    }\n    if (globalColumns.length > 0) {\n        columnDescription.push({title: 'Global variables', columns: globalColumns});\n    }\n\n    // Finally, we prepare the groups for each part\n    let partColumns = [];\n    let partIndex = 0;\n    for (let part of firstRow.parts) {\n        let thisPartsColumns = [];\n        for (let vars of part) {\n            thisPartsColumns.push({\n                title: vars.name,\n                field: `part_${partIndex}_${vars.name}`,\n                ...calcOptions\n            });\n        }\n        partColumns.push({title: `Part ${partIndex + 1}`, columns: thisPartsColumns});\n        partIndex++;\n    }\n    columnDescription = [...columnDescription, ...partColumns];\n    Tabulator.findTable(\"#varsdata_display\")[0].setColumns(columnDescription);\n    fillTable(data);\n    // Fetch and show localized column group titles for random/global/part variables.\n    localizeColumnGroupNames();\n\n\n    // We do not show the calculation row in the footer if there's just one data set.\n    let holders = document.querySelectorAll('div.tabulator-calcs-holder');\n    for (let holder of holders) {\n        holder.style.display = (data.length > 1 ? 'block' : 'none');\n    }\n};\n\n/**\n * Make sure the column titles for random, global and part variables are localized.\n *\n * @returns {void}\n */\nconst localizeColumnGroupNames = async() => {\n    // For proper localization, we need to fetch the text for each part separately, because\n    // in some languages, the number might come before the word.\n    let partStringRequests = [];\n    for (let i = 0; i < numberOfParts; i++) {\n        partStringRequests.push({key: 'answerno', component: 'qtype_formulas', param: i + 1});\n    }\n    let strings = null;\n    let pendingPromise = new Pending('qtype_formulas/localization');\n    try {\n        strings = await String.get_strings([\n            {key: 'varsrandom', component: 'qtype_formulas'},\n            {key: 'varsglobal', component: 'qtype_formulas'},\n            ...partStringRequests\n        ]);\n    } catch (err) {\n        Notification.exception(err);\n    }\n    pendingPromise.resolve();\n    // If fetching of strings was not successful, we quit here.\n    if (strings === null) {\n        return;\n    }\n\n    // Fetch all column groups. Unfortunately, Tabulator.js does currently only offer\n    // an API to change column titles if the columns are not grouped. Therefore, we're\n    // doing it manually.\n    let columnGroups = document.querySelectorAll('div.tabulator-col-group');\n    let i = 1;\n    for (let group of columnGroups) {\n        // We do not always have random and global variables, so it's better to make sure.\n        if (group.getAttribute('aria-title') == 'Random variables') {\n            setTitleForColumnGroup(group, strings[0]);\n            continue;\n        }\n        if (group.getAttribute('aria-title') == 'Global variables') {\n            setTitleForColumnGroup(group, strings[1]);\n            continue;\n        }\n        // Remaining groups are for parts and there will always be at least one part.\n        setTitleForColumnGroup(group, strings[1 + i]);\n        i++;\n    }\n};\n\n/**\n * Helper function to set the title and aria-title for a column group header.\n * @param {Element} element the <div> holding the column title\n * @param {string} title the new title\n */\nconst setTitleForColumnGroup = (element, title) => {\n    element.setAttribute('aria-title', title);\n    element.querySelector('div.tabulator-col-title').innerText = title;\n};\n\n/**\n * Prepare the data and send it to the Tabulator.js table for display.\n *\n * @param {object} data instantiation data as received from the backend\n */\nconst fillTable = (data) => {\n    let allRows = [];\n    let rowCounter = 0;\n    for (let row of data) {\n        let thisRow = {id: ++rowCounter};\n        for (let thisVar of row.randomvars) {\n            thisRow[`random_${thisVar.name}`] = thisVar.value;\n        }\n        for (let thisVar of row.globalvars) {\n            thisRow[`global_${thisVar.name}`] = thisVar.value;\n        }\n        let partCounter = 0;\n        for (let thisPart of row.parts) {\n            for (let thisVar of thisPart) {\n                thisRow[`part_${partCounter}_${thisVar.name}`] = thisVar.value;\n            }\n            partCounter++;\n        }\n        allRows.push(thisRow);\n    }\n\n    Tabulator.findTable(\"#varsdata_display\")[0].setData(allRows);\n};\n\n/**\n * Send the definition of random variables, global variables and parts' local variables\n * to the backend for instantiation. This will generate a certain number of rows, based\n * on the number the user has selected in the corresponding dropdown field. Once the\n * AJAX requeset is completed, the data will be forwarded to {@link prepareTableColumns}.\n */\nconst instantiate = async() => {\n    let howMany = document.getElementById('id_numdataset').value;\n    let localvars = [];\n    let answers = [];\n    for (let i = 0; i < numberOfParts; i++) {\n        localvars[i] = document.getElementById(`id_vars1_${i}`).value;\n        answers[i] = document.getElementById(`id_answer_${i}`).value;\n    }\n    let pendingPromise = new Pending('qtype_formulas/instantiate');\n    try {\n        let response = await fetchMany([{\n            methodname: 'qtype_formulas_instantiate',\n            args: {\n                n: howMany,\n                randomvars: document.getElementById('id_varsrandom').value,\n                globalvars: document.getElementById('id_varsglobal').value,\n                localvars: localvars,\n                answers: answers\n            }\n        }])[0];\n        if (response.status == 'error') {\n            let str = await String.get_string('previewerror', 'qtype_formulas');\n            document.getElementById('qtextpreview_display').innerHTML = `${str}<br>${response.message}`;\n        } else {\n            document.getElementById('qtextpreview_display').innerHTML = '';\n            prepareTableColumns(response.data);\n        }\n    } catch (err) {\n        Notification.exception(err);\n    }\n    pendingPromise.resolve();\n};\n\n/**\n * Event handler for the global variables definition. The function will send the text to\n * the backend and try to evaluate it (together with the random variables, because global\n * variables can be based on random variables). If there is an error, it will be shown\n * in the form via {@link showOrClearValidationError}.\n *\n * @param {Event} evt Event object\n */\nconst validateGlobalvars = async(evt) => {\n    // We don't validate an empty field. But if there is an error from earlier validation,\n    // we must make sure it is removed.\n    if (evt.target.value === '') {\n        showOrClearValidationError(evt.target.id, '');\n        return;\n    }\n    let pendingPromise = new Pending('qtype_formulas/validateglobal');\n    try {\n        let validationResult = await fetchMany([{\n            methodname: 'qtype_formulas_check_random_global_vars',\n            args: {\n                randomvars: document.getElementById('id_varsrandom').value,\n                globalvars: evt.target.value\n            },\n        }])[0];\n        if (validationResult.source === '' || validationResult.source === 'global') {\n            showOrClearValidationError(evt.target.id, validationResult.message);\n        } else {\n            showOrClearValidationError('id_varsrandom', validationResult.message, false);\n        }\n    } catch (err) {\n        Notification.exception(err);\n    }\n    pendingPromise.resolve();\n};\n\n/**\n * Event handler for the random variables definition. The function will send the text to\n * the backend which tries to parse it and instantiate the variables. If there is an error,\n * it will be shown in the form via {@link showOrClearValidationError}.\n *\n * @param {Event} evt Event object\n */\nconst validateRandomvars = async(evt) => {\n    // We don't validate an empty field. But if there is an error from earlier validation,\n    // we must make sure it is removed.\n    if (evt.target.value === '') {\n        showOrClearValidationError(evt.target.id, '');\n        return;\n    }\n    let pendingPromise = new Pending('qtype_formulas/validaterandom');\n    try {\n        let validationResult = await fetchMany([{\n            methodname: 'qtype_formulas_check_random_global_vars',\n            args: {\n                randomvars: evt.target.value\n            },\n        }])[0];\n        showOrClearValidationError(evt.target.id, validationResult.message);\n    } catch (err) {\n        Notification.exception(err);\n    }\n    pendingPromise.resolve();\n};\n\nconst validateLocalvars = async(part) => {\n    let fieldList = {\n        'random': 'id_varsrandom',\n        'global': 'id_varsglobal',\n        'local': `id_vars1_${part}`\n    };\n    let target = document.getElementById(fieldList.local);\n    // We don't validate an empty field. But if there is an error from earlier validation,\n    // we must make sure it is removed.\n    if (target.value === '') {\n        showOrClearValidationError(target.id, '');\n        return;\n    }\n    let pendingPromise = new Pending('qtype_formulas/validatelocal');\n    try {\n        let validationResult = await fetchMany([{\n            methodname: 'qtype_formulas_check_local_vars',\n            args: {\n                randomvars: document.getElementById(fieldList.random).value,\n                globalvars: document.getElementById(fieldList.global).value,\n                localvars: target.value\n            }\n        }])[0];\n        if (validationResult.source === '') {\n            validationResult.source = 'local';\n        }\n        showOrClearValidationError(\n            fieldList[validationResult.source],\n            validationResult.message,\n            validationResult.source === 'local'\n        );\n    } catch (err) {\n        Notification.exception(err);\n    }\n    pendingPromise.resolve();\n};\n\n/**\n * Show a validation error below the corresponding form field and set the field\n * as invalid. Or remove message and marking, if there is no error anymore.\n *\n * @param {string} fieldID id of the form field to which the error belongs\n * @param {string} message error message or empty string, if error is to be removed\n * @param {boolean} sameField did the error occur in the field that was originally validated\n */\nconst showOrClearValidationError = (fieldID, message, sameField = true) => {\n    let field = document.getElementById(fieldID);\n    let annotation = document.getElementById(fieldID.replace(/^id_(.*)$/, 'id_error_$1'));\n    let alreadyWithError = (annotation.innerText.trim() !== '');\n    if (message === '') {\n        annotation.innerText = '';\n        field.classList.remove('is-invalid');\n        return;\n    }\n    annotation.innerText = message;\n    field.classList.add('is-invalid');\n    // If there is already an error in *this* field, we don't generally force the focus,\n    // because that could trap the user. We do, however, set the focus, if the prior error\n    // occured in another field.\n    if (!alreadyWithError || !sameField) {\n        field.focus();\n    }\n};\n\n/**\n * The textfields containing the grading criterion might be disabled. However, as disabled elements\n * do not submit their value, they have to be enabled before submitting the form.\n */\nconst reenableCriterionTextfields = () => {\n    for (let i = 0; i < numberOfParts; i++) {\n        document.getElementById(`id_correctness_${i}`).disabled = false;\n    }\n};\n\n/**\n * Handle change event for the elements that allow simplified entry of the grading criterion.\n * On each modification, the current criterion is propagated to the (hidden) textbox,\n * that will be used to store the criterion in the database upon submission of the form.\n * @param {number} partNumber number of the part\n */\nconst handleSimpleCriterionChanges = (partNumber) => {\n    let textbox = document.getElementById(`id_correctness_${partNumber}`);\n    textbox.value = convertSimpleCriterionToText(partNumber);\n};\n\n/**\n * Parse the tolerance value into a number and put the value back into the textfield.\n * This allows for immediate simplification and some validation; invalid numbers will be replaced by 0.\n * @param {Event} event Event containing the textfield to be normalized\n */\nconst normalizeTolerance = (event) => {\n    let field = event.target;\n    let tolerance = parseFloat(field.value);\n\n    if (isNaN(tolerance) || !isFinite(tolerance)) {\n        tolerance = 0;\n    }\n\n    field.value = tolerance;\n};\n\n/**\n * Switch between simplified and normal entry mode for the grading criterion.\n * @param {number} partNumber number of the part\n */\nconst handleGradingCriterionModeSwitcher = (partNumber) => {\n    let checkbox = document.getElementById(`id_correctness_simple_mode_${partNumber}`);\n\n    let criterionTextfield = document.getElementById(`id_correctness_${partNumber}`);\n\n    // If not checked anymore, activate expert mode --> convert settings to string and set textfield.\n    if (!checkbox.checked) {\n        criterionTextfield.value = convertSimpleCriterionToText(partNumber);\n        return;\n    }\n\n    // Activate simple mode. If input field is empty, use default value.\n    if (criterionTextfield.value.trim() == '') {\n        criterionTextfield.value = defaultCorrectness;\n    }\n\n    let simpleCriterion = convertTextCriterionToSimple(partNumber);\n    document.getElementById(`id_correctness_simple_type_${partNumber}`).value = simpleCriterion.type;\n    document.getElementById(`id_correctness_simple_comp_${partNumber}`).value = simpleCriterion.comparison;\n    document.getElementById(`id_correctness_simple_tol_${partNumber}`).value = simpleCriterion.tolerance;\n};\n\n/**\n * Convert the simple grading criterion into the corresponding text.\n * @param {number} partNumber number of the part\n * @returns {string} text form of the grading criterion\n */\nconst convertSimpleCriterionToText = (partNumber) => {\n    let typeElement = document.getElementById(`id_correctness_simple_type_${partNumber}`);\n    let comparisonElement = document.getElementById(`id_correctness_simple_comp_${partNumber}`);\n    let toleranceElement = document.getElementById(`id_correctness_simple_tol_${partNumber}`);\n\n    return ['_relerr', '_err'][typeElement.value] + ' '\n        + comparisonElement.options[comparisonElement.value].innerText + ' '\n        + parseFloat(toleranceElement.value);\n};\n\n/**\n * Convert the grading criterion into the simplified form.\n * @param {number} partNumber number of the part\n * @returns {object} criterion the simplified grading criterion\n * @returns {number} criterion.type the type of error (relative or absolute)\n * @returns {number} criterion.comparison the comparison (== or <)\n * @returns {number} criteron.tolerance the tolerance value\n * @throws {TypeError} throws if the value cannot be converted\n */\nconst convertTextCriterionToSimple = (partNumber) => {\n    // Split input into its parts (type, comparison, tolerance).\n    let criterionParts = document.getElementById(`id_correctness_${partNumber}`).value.split(/\\s*(==|<)\\s*/);\n\n    // This should not happen, but it might be better to check anyway.\n    if (criterionParts.length != 3 || !criterionParts[0].match(/^\\s*_(rel)?err\\s*$/)) {\n        throw new TypeError('The given grading criterion cannot be shown in simple mode.');\n    }\n\n    return {\n        'type': ['_relerr', '_err'].indexOf(criterionParts[0]),\n        'comparison': ['==', '<'].indexOf(criterionParts[1]),\n        'tolerance': parseFloat(criterionParts[2])\n    };\n};\n\n/**\n * Check whether the current grading criterion can be converted into the simplified form.\n * If not, disable the checkbox that would allow switching to simple mode.\n * If yes, enable sais checkbox.\n * If the text box is empty, conversion is possible using the default value.\n * @param {number} partNumber number of the part\n */\nconst blockModeSwitcherIfNeeded = (partNumber) => {\n    let criterion = document.getElementById(`id_correctness_${partNumber}`).value.trim();\n    let modeCheckbox = document.getElementById(`id_correctness_simple_mode_${partNumber}`);\n    // If textfield is empty, allow conversion to easy mode\n    if (criterion == '') {\n        modeCheckbox.disabled = false;\n        return;\n    }\n\n    // Value must have exactly three parts: type + comparison + tolerance (number).\n    let criterionParts = criterion.split(/\\s*(==|<)\\s*/);\n    if (criterionParts.length != 3) {\n        modeCheckbox.disabled = true;\n        return;\n    }\n\n    // Type must be _relerr or _err.\n    if (!criterionParts[0].match(/^\\s*_(rel)?err\\s*$/)) {\n        modeCheckbox.disabled = true;\n        return;\n    }\n\n    // Comparison must be == or <.\n    if (!criterionParts[1].match(/\\s*(==|<)\\s*$/)) {\n        modeCheckbox.disabled = true;\n        return;\n    }\n\n    // Tolerance must be a number.\n    let tolerance = parseFloat(criterionParts[2]);\n    // As parseFloat ignores trailing characters, we check for that separately;\n    // we just don't want the tolerance number to contain obviously invalid characters.\n    if (isNaN(tolerance) || !isFinite(tolerance) || criterionParts[2].match(/[^-+0-9.e]/)) {\n        modeCheckbox.disabled = true;\n        return;\n    }\n\n    modeCheckbox.disabled = false;\n};\n\nexport default {init};\n"],"names":["defaultCorrectness","numberOfParts","init","defCorrectness","document","querySelectorAll","length","extendTabulator","initTable","i","textfield","getElementById","form","addEventListener","reenableCriterionTextfields","blockModeSwitcherIfNeeded","bind","checkbox","handleGradingCriterionModeSwitcher","dispatchEvent","Event","disabled","classList","contains","checked","element","handleSimpleCriterionChanges","normalizeTolerance","variableFields","field","handler","validateRandomvars","validateGlobalvars","push","validateLocalvars","instantiate","extendModule","values","count","min","Infinity","max","sum","value","parseFloat","Math","isNaN","toFixed","Tabulator","selectable","movableColumns","pagination","paginationSize","paginationButtonCount","columns","title","langs","on","previewQuestionWithDataset","quoteNonNumericValue","startsWith","quotedElements","substring","split","join","fetchTextFromEditor","id","window","tinyMCE","get","getContent","row","getElement","data","getData","questionvars","partvars","Array","fill","varname","match","replace","index","parseInt","parttexts","pendingPromise","Pending","methodname","args","questiontext","globalvars","renderedTexts","showRenderedQuestionAndParts","Notification","exception","resolve","div","innerHTML","question","parts","text","MathJax","version","typesetPromise","Hub","Queue","triggerMathJax","prepareTableColumns","firstRow","calcOptions","bottomCalc","bottomCalcFormatter","cell","getValue","columnDescription","randomColumns","randomvars","column","name","globalColumns","partColumns","partIndex","part","thisPartsColumns","vars","findTable","setColumns","fillTable","localizeColumnGroupNames","style","display","partStringRequests","key","component","param","strings","String","get_strings","columnGroups","group","getAttribute","setTitleForColumnGroup","setAttribute","querySelector","innerText","allRows","rowCounter","thisRow","thisVar","partCounter","setData","howMany","localvars","answers","n","response","status","get_string","str","message","evt","target","showOrClearValidationError","validationResult","source","fieldList","local","random","global","fieldID","sameField","annotation","alreadyWithError","trim","remove","add","focus","partNumber","convertSimpleCriterionToText","event","tolerance","isFinite","criterionTextfield","simpleCriterion","convertTextCriterionToSimple","type","comparison","typeElement","comparisonElement","toleranceElement","options","criterionParts","TypeError","indexOf","criterion","modeCheckbox"],"mappings":"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"}