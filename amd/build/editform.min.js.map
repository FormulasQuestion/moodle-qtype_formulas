{"version":3,"file":"editform.min.js","sources":["../src/editform.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Helper functions for the form used to create / edit a formulas question.\n *\n * @module     qtype_formulas/editform\n * @copyright  2022 Philipp Imhof\n * @author     Philipp Imhof\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport * as Notification from 'core/notification';\nimport * as String from 'core/str';\nimport {call as fetchMany} from 'core/ajax';\nimport {TabulatorFull as Tabulator} from 'qtype_formulas/tabulator';\n\n/**\n * Default grading criterion according to plugin settings (admin)\n */\nvar defaultCorrectness = '';\n\n/**\n * Number of subquestions (parts)\n */\nvar numberOfParts = 0;\n\nexport const init = (defCorrectness) => {\n    defaultCorrectness = defCorrectness;\n    numberOfParts = document.querySelectorAll('fieldset[id^=id_answerhdr_]').length;\n\n    extendTabulator();\n    initTable();\n\n    for (let i = 0; i < numberOfParts; i++) {\n        let textfield = document.getElementById(`id_correctness_${i}`);\n\n        // Event listener for the submission of the form (attach only once)\n        if (i === 0) {\n            textfield.form.addEventListener('submit', reenableCriterionTextfields);\n        }\n\n        // Constantly check whether the current grading criterion is simple enough\n        // to allow to switch to simple mode.\n        textfield.addEventListener('input', blockModeSwitcherIfNeeded.bind(null, i));\n\n        let checkbox = document.getElementById(`id_correctness_simple_mode_${i}`);\n        checkbox.addEventListener('click', handleGradingCriterionModeSwitcher.bind(null, i));\n\n        // Trigger input event in criterion textfields in order to disable the mode switcher\n        // checkbox, if needed. If the criterion is simple enough, start with simple mode,\n        // unless the form comes back from validation and the textfield is marked as invalid.\n        textfield.dispatchEvent(new Event('input'));\n        if (!checkbox.disabled && !textfield.classList.contains('is-invalid')) {\n            checkbox.checked = true;\n            checkbox.dispatchEvent(new Event('click'));\n        }\n\n        // Always keep the textual form of the grading criterion in sync, because that's\n        // what is going to be submitted in the end.\n        let elements = ['type', 'comp', 'tol'];\n        for (let element of elements) {\n            document.getElementById(`id_correctness_simple_${element}_${i}`).addEventListener(\n                'change', handleSimpleCriterionChanges.bind(null, i)\n            );\n        }\n        document.getElementById(`id_correctness_simple_tol_${i}`).addEventListener(\n            'change', normalizeTolerance\n        );\n    }\n\n    // When the definition of random, global or any part's local variables is changed,\n    // have them validated by the backend.\n    let variableFields = [{field: 'random', handler: validateRandomvars}, {field: 'global', handler: validateGlobalvars}];\n    for (let i = 0; i < numberOfParts; i++) {\n        variableFields.push({field: `1_${i}`, handler: validateLocalvars.bind(null, i)});\n    }\n    for (let field of variableFields) {\n        document.getElementById(`id_vars${field.field}`).addEventListener(\n            'change', field.handler\n        );\n    }\n\n    // Event listener for the \"instantiate\" button.\n    document.getElementById('id_instantiatebtn').addEventListener(\n        'click', instantiate\n    );\n};\n\n/**\n * Add some customizations to Tabulator.js\n */\nconst extendTabulator = () => {\n    Tabulator.extendModule('columnCalcs', 'calculations', {\n        'stats': (values) => {\n            var count = 0;\n            var min = Infinity;\n            var max = -Infinity;\n            var sum = 0;\n\n            for (let value of values) {\n                sum += parseFloat(value);\n                min = Math.min(min, value);\n                max = Math.max(max, value);\n                count++;\n            }\n\n            // If minimum and maximum are the same, we don't display the stats, because\n            // the values are constant.\n            if (min === max) {\n                return ['', '', ''];\n            }\n\n            if (count > 0 && !isNaN(sum)) {\n                return [(sum / count).toFixed(1), min, max];\n            }\n            return ['', '', ''];\n        },\n    });\n};\n\n/**\n * Init the table we use for checking the variables' instantiation.\n */\nconst initTable = () => {\n    let table = new Tabulator('#varsdata_display', {\n        selectable: 1,\n        movableColumns: true,\n        pagination: 'local',\n        paginationSize: 10,\n        paginationButtonCount: 0,\n        columns: [\n            {title: '#', field: 'id'},\n        ],\n        langs: {\n            'default': {\n                'pagination': {\n                    'first': '⏮',\n                    'last': '⏭',\n                    'prev': '⏪',\n                    'next': '⏩'\n                }\n            }\n        },\n    });\n    table.on('rowSelected', previewQuestionWithDataset);\n};\n\n/**\n * For proper parsing in the backend, strings must be enclosed in double quotes,\n * but numbers must not.\n *\n * @param {string} value representation of a numberic, string or list (array) value\n * @returns {string} the same value, but with quotes added, if necessary\n */\nconst quoteNonNumericValue = (value) => {\n    // Numbers must not be quoted.\n    if (!isNaN(value)) {\n        return value;\n    }\n    // For arrays, we have to check each element individually and quote, if necessary.\n    // Formulas question does not currently support nested arrays, so we don't have to deal with that.\n    if (value.startsWith('[')) {\n        let quotedElements = [];\n        // Remove leading and trailing bracket\n        value = value.substring(1, value.length - 1);\n        let elements = value.split(/\\s*,\\s*/);\n        for (let element of elements) {\n            quotedElements.push(quoteNonNumericValue(element));\n        }\n        return '[' + quotedElements.join(', ') + ']';\n    }\n    // Not a number and not an array, so we enclose it in double quotes.\n    return `\"${value}\"`;\n};\n\n/**\n * The question text and the parts' text are stored in the editor. For some editors,\n * we can take the content from the textarea's value attribute. For TinyMCE (and maybe others),\n * we must use the corresponding API.\n *\n * @param {string} id id of the textarea\n * @returns {string} the question or part's text\n */\nconst fetchTextFromEditor = (id) => {\n    if (typeof window.tinyMCE !== 'undefined') {\n        return window.tinyMCE.get(id).getContent();\n    }\n    return document.getElementById(id).value;\n};\n\n/**\n * Extract data from the instantiation table (selected row) and send them to the backend,\n * in order to have the question text and parts' text rendered for the preview.\n *\n * @param {object} row RowComponent from Tabulator.js\n */\nconst previewQuestionWithDataset = (row) => {\n    // The statistics row is clickable, but we cannot use its data to preview the question.\n    if (row.getElement().classList.contains('tabulator-calcs')) {\n        return;\n    }\n    let data = row.getData();\n    let questionvars = '';\n    let partvars = Array(numberOfParts).fill('');\n\n    for (let varname in data) {\n        // Variables for the main question are all random or global.\n        // Also, as random variables have already been instantiated, they are not random anymore.\n        if (varname.match(/^(random|global)_/)) {\n            questionvars += varname.replace(/^(random|global)_([^*]+)\\*?$/, '$2') + '=';\n            questionvars += quoteNonNumericValue(data[varname]) + ';';\n        }\n        // Variables for a question part always start with part_ + number of the part\n        if (varname.match(/^part_(\\d+)_/)) {\n            // If the variable name starts with _ it should be removed, as these are\n            // answers (or otherwise reserved names, but that should not be the case)\n            if (varname.match(/^part_(\\d+)__/)) {\n                continue;\n            }\n            let index = parseInt(varname.replace(/^part_(\\d+)_.*$/, '$1'));\n            partvars[index] += varname.replace(/^part_(\\d+)_([^*]+)\\*?$/, '$2') + '=';\n            partvars[index] += quoteNonNumericValue(data[varname]) + ';';\n        }\n    }\n\n    let parttexts = [];\n    for (let i = 0; i < numberOfParts; i++) {\n        parttexts[i] = fetchTextFromEditor(`id_subqtext_${i}`);\n    }\n\n    fetchMany([{\n        methodname: 'qtype_formulas_render_question_text',\n        args: {\n            questiontext: fetchTextFromEditor('id_questiontext'),\n            parttexts: parttexts,\n            globalvars: questionvars,\n            partvars: partvars\n        },\n        done: showRenderedQuestionAndParts,\n        fail: Notification.exception\n    }]);\n};\n\n/**\n * Trigger MathJax rendering for the question.\n *\n * @param {Element} element the <div> element where the question text is shown\n */\nconst triggerMathJax = (element) => {\n    if (typeof window.MathJax === 'undefined') {\n        return;\n    }\n    let version = window.MathJax.version;\n    if (version[0] == '2') {\n        window.MathJax.Hub.Queue(['Typeset', window.MathJax.Hub, element]);\n        return;\n    }\n    if (version[0] == '3') {\n        window.MathJax.typesetPromise([element]);\n    }\n};\n\n/**\n * This function is called after the AJAX request to the backend is completed. It will inject\n * the rendered texts into the preview div.\n *\n * @param {object} data rendered version of question text and parts' text\n */\nconst showRenderedQuestionAndParts = (data) => {\n    let div = document.getElementById('qtextpreview_display');\n    div.innerHTML = data.question;\n    for (let text of data.parts) {\n        div.innerHTML += text;\n    }\n    triggerMathJax(div);\n};\n\n/**\n * Derive the column description from the instantiated variables.\n *\n * @param {object} data instantiation data as received from the backend\n */\nconst prepareTableColumns = (data) => {\n    if (data.status == 'error') {\n        String.get_string('previewerror', 'qtype_formulas').then((str) => {\n            document.getElementById('qtextpreview_display').innerHTML = `${str}<br>${data.message}`;\n        }).catch();\n        return;\n    }\n    let firstRow = data.data[0];\n    let calcOptions = {bottomCalc: 'stats', bottomCalcFormatter: (cell) => cell.getValue().join('<br>')};\n    let columnDescription = [{title: '#', field: 'id', bottomCalcFormatter: () => '⌀<br>min</br>max'}];\n\n    // Random variables come first\n    let randomColumns = [];\n    for (let column of firstRow.randomvars) {\n        randomColumns.push({\n            title: column.name,\n            field: `random_${column.name}`,\n            ...calcOptions\n        });\n    }\n    if (randomColumns.length > 0) {\n        columnDescription.push({title: 'Random variables', columns: randomColumns});\n    }\n\n    // Then we take the global variables\n    let globalColumns = [];\n    for (let column of firstRow.globalvars) {\n        globalColumns.push({\n            title: column.name,\n            field: `global_${column.name}`,\n            ...calcOptions\n        });\n    }\n    if (globalColumns.length > 0) {\n        columnDescription.push({title: 'Global variables', columns: globalColumns});\n    }\n\n    // Finally, we prepare the groups for each part\n    let partColumns = [];\n    let partIndex = 0;\n    for (let part of firstRow.parts) {\n        let thisPartsColumns = [];\n        for (let vars of part) {\n            thisPartsColumns.push({\n                title: vars.name,\n                field: `part_${partIndex}_${vars.name}`,\n                ...calcOptions\n            });\n        }\n        partColumns.push({title: `Part ${partIndex + 1}`, columns: thisPartsColumns});\n        partIndex++;\n    }\n    columnDescription = [...columnDescription, ...partColumns];\n    Tabulator.findTable(\"#varsdata_display\")[0].setColumns(columnDescription);\n    fillTable(data);\n\n    // We do not show the calculation row in the footer if there's just one data set.\n    let holders = document.querySelectorAll('div.tabulator-calcs-holder');\n    for (let holder of holders) {\n        holder.style.display = (data.data.length > 1 ? 'block' : 'none');\n    }\n};\n\n/**\n * Prepare the data and send it to the Tabulator.js table for display.\n *\n * @param {object} data instantiation data as received from the backend\n */\nconst fillTable = (data) => {\n    let allRows = [];\n    let rowCounter = 0;\n    for (let row of data.data) {\n        let thisRow = {id: ++rowCounter};\n        for (let thisVar of row.randomvars) {\n            thisRow[`random_${thisVar.name}`] = thisVar.value;\n        }\n        for (let thisVar of row.globalvars) {\n            thisRow[`global_${thisVar.name}`] = thisVar.value;\n        }\n        let partCounter = 0;\n        for (let thisPart of row.parts) {\n            for (let thisVar of thisPart) {\n                thisRow[`part_${partCounter}_${thisVar.name}`] = thisVar.value;\n            }\n            partCounter++;\n        }\n        allRows.push(thisRow);\n    }\n\n    Tabulator.findTable(\"#varsdata_display\")[0].setData(allRows);\n};\n\n/**\n * Send the definition of random variables, global variables and parts' local variables\n * to the backend for instantiation. This will generate a certain number of rows, based\n * on the number the user has selected in the corresponding dropdown field. Once the\n * AJAX requeset is completed, the data will be forwarded to {@link prepareTableColumns}.\n */\nconst instantiate = () => {\n    let howMany = document.getElementById('id_numdataset').value;\n    let localvars = [];\n    let answers = [];\n    for (let i = 0; i < numberOfParts; i++) {\n        localvars[i] = document.getElementById(`id_vars1_${i}`).value;\n        answers[i] = document.getElementById(`id_answer_${i}`).value;\n    }\n    fetchMany([{\n        methodname: 'qtype_formulas_instantiate',\n        args: {\n            n: howMany,\n            randomvars: document.getElementById('id_varsrandom').value,\n            globalvars: document.getElementById('id_varsglobal').value,\n            localvars: localvars,\n            answers: answers\n        },\n        done: prepareTableColumns,\n        fail: Notification.exception\n    }]);\n};\n\n/**\n * Event handler for the global variables definition. The function will send the text to\n * the backend and try to evaluate it (together with the random variables, because global\n * variables can be based on random variables). If there is an error, it will be shown\n * in the form via {@link showOrClearValidationError}.\n *\n * @param {Event} evt Event object\n */\nconst validateGlobalvars = (evt) => {\n    // We don't validate an empty field. But if there is an error from earlier validation,\n    // we must make sure it is removed.\n    if (evt.target.value === '') {\n        showOrClearValidationError(evt.target.id, '');\n        return;\n    }\n    fetchMany([{\n        methodname: 'qtype_formulas_check_random_global_vars',\n        args: {\n            randomvars: document.getElementById('id_varsrandom').value,\n            globalvars: evt.target.value\n        },\n        done: (answer) => {\n            showOrClearValidationError(evt.target.id, answer);\n        },\n        fail: Notification.exception\n    }]);\n};\n\n/**\n * Event handler for the random variables definition. The function will send the text to\n * the backend which tries to parse it and instantiate the variables. If there is an error,\n * it will be shown in the form via {@link showOrClearValidationError}.\n *\n * @param {Event} evt Event object\n */\nconst validateRandomvars = (evt) => {\n    // We don't validate an empty field. But if there is an error from earlier validation,\n    // we must make sure it is removed.\n    if (evt.target.value === '') {\n        showOrClearValidationError(evt.target.id, '');\n        return;\n    }\n    fetchMany([{\n        methodname: 'qtype_formulas_check_random_global_vars',\n        args: {\n            randomvars: evt.target.value\n        },\n        done: (answer) => {\n            showOrClearValidationError(evt.target.id, answer);\n        },\n        fail: Notification.exception\n    }]);\n};\n\nconst validateLocalvars = (part) => {\n    let target = document.getElementById(`id_vars1_${part}`);\n    // We don't validate an empty field. But if there is an error from earlier validation,\n    // we must make sure it is removed.\n    if (target.value === '') {\n        showOrClearValidationError(target.id, '');\n        return;\n    }\n    fetchMany([{\n        methodname: 'qtype_formulas_check_local_vars',\n        args: {\n            randomvars: document.getElementById('id_varsrandom').value,\n            globalvars: document.getElementById('id_varsglobal').value,\n            localvars: target.value\n        },\n        done: (answer) => {\n            showOrClearValidationError(target.id, answer);\n        },\n        fail: Notification.exception\n    }]);\n};\n\n/**\n * Show a validation error below the corresponding form field and set the field\n * as invalid. Or remove message and marking, if there is no error anymore.\n *\n * @param {string} fieldID id of the form field to which the error belongs\n * @param {string} message error message or empty string, if error is to be removed\n */\nconst showOrClearValidationError = (fieldID, message) => {\n    let field = document.getElementById(fieldID);\n    let annotation = document.getElementById(fieldID.replace(/^id_(.*)$/, 'id_error_$1'));\n    if (message === '') {\n        annotation.innerText = '';\n        field.classList.remove('is-invalid');\n    } else {\n        annotation.innerText = message;\n        field.classList.add('is-invalid');\n        field.focus();\n    }\n};\n\n/**\n * The textfields containing the grading criterion might be disabled. However, as disabled elements\n * do not submit their value, they have to be enabled before submitting the form.\n */\nconst reenableCriterionTextfields = () => {\n    for (let i = 0; i < numberOfParts; i++) {\n        document.getElementById(`id_correctness_${i}`).disabled = false;\n    }\n};\n\n/**\n * Handle change event for the elements that allow simplified entry of the grading criterion.\n * On each modification, the current criterion is propagated to the (hidden) textbox,\n * that will be used to store the criterion in the database upon submission of the form.\n * @param {number} partNumber number of the part\n */\nconst handleSimpleCriterionChanges = (partNumber) => {\n    let textbox = document.getElementById(`id_correctness_${partNumber}`);\n    textbox.value = convertSimpleCriterionToText(partNumber);\n};\n\n/**\n * Parse the tolerance value into a number and put the value back into the textfield.\n * This allows for immediate simplification and some validation; invalid numbers will be replaced by 0.\n * @param {Event} event Event containing the textfield to be normalized\n */\nconst normalizeTolerance = (event) => {\n    let field = event.target;\n    let tolerance = parseFloat(field.value);\n\n    if (isNaN(tolerance) || !isFinite(tolerance)) {\n        tolerance = 0;\n    }\n\n    field.value = tolerance;\n};\n\n/**\n * Switch between simplified and normal entry mode for the grading criterion.\n * @param {number} partNumber number of the part\n */\nconst handleGradingCriterionModeSwitcher = (partNumber) => {\n    let checkbox = document.getElementById(`id_correctness_simple_mode_${partNumber}`);\n\n    let criterionTextfield = document.getElementById(`id_correctness_${partNumber}`);\n\n    // If not checked anymore, activate expert mode --> convert settings to string and set textfield.\n    if (!checkbox.checked) {\n        criterionTextfield.value = convertSimpleCriterionToText(partNumber);\n        return;\n    }\n\n    // Activate simple mode. If input field is empty, use default value.\n    if (criterionTextfield.value.trim() == '') {\n        criterionTextfield.value = defaultCorrectness;\n    }\n\n    let simpleCriterion = convertTextCriterionToSimple(partNumber);\n    document.getElementById(`id_correctness_simple_type_${partNumber}`).value = simpleCriterion.type;\n    document.getElementById(`id_correctness_simple_comp_${partNumber}`).value = simpleCriterion.comparison;\n    document.getElementById(`id_correctness_simple_tol_${partNumber}`).value = simpleCriterion.tolerance;\n};\n\n/**\n * Convert the simple grading criterion into the corresponding text.\n * @param {number} partNumber number of the part\n * @returns {string} text form of the grading criterion\n */\nconst convertSimpleCriterionToText = (partNumber) => {\n    let typeElement = document.getElementById(`id_correctness_simple_type_${partNumber}`);\n    let comparisonElement = document.getElementById(`id_correctness_simple_comp_${partNumber}`);\n    let toleranceElement = document.getElementById(`id_correctness_simple_tol_${partNumber}`);\n\n    return ['_relerr', '_err'][typeElement.value] + ' '\n        + comparisonElement.options[comparisonElement.value].innerText + ' '\n        + parseFloat(toleranceElement.value);\n};\n\n/**\n * Convert the grading criterion into the simplified form.\n * @param {number} partNumber number of the part\n * @returns {object} criterion the simplified grading criterion\n * @returns {number} criterion.type the type of error (relative or absolute)\n * @returns {number} criterion.comparison the comparison (== or <)\n * @returns {number} criteron.tolerance the tolerance value\n * @throws {TypeError} throws if the value cannot be converted\n */\nconst convertTextCriterionToSimple = (partNumber) => {\n    // Split input into its parts (type, comparison, tolerance).\n    let criterionParts = document.getElementById(`id_correctness_${partNumber}`).value.split(/\\s*(==|<)\\s*/);\n\n    // This should not happen, but it might be better to check anyway.\n    if (criterionParts.length != 3 || !criterionParts[0].match(/^\\s*_(rel)?err\\s*$/)) {\n        throw new TypeError('The given grading criterion cannot be shown in simple mode.');\n    }\n\n    return {\n        'type': ['_relerr', '_err'].indexOf(criterionParts[0]),\n        'comparison': ['==', '<'].indexOf(criterionParts[1]),\n        'tolerance': parseFloat(criterionParts[2])\n    };\n};\n\n/**\n * Check whether the current grading criterion can be converted into the simplified form.\n * If not, disable the checkbox that would allow switching to simple mode.\n * If yes, enable sais checkbox.\n * If the text box is empty, conversion is possible using the default value.\n * @param {number} partNumber number of the part\n */\nconst blockModeSwitcherIfNeeded = (partNumber) => {\n    let criterion = document.getElementById(`id_correctness_${partNumber}`).value.trim();\n    let modeCheckbox = document.getElementById(`id_correctness_simple_mode_${partNumber}`);\n    // If textfield is empty, allow conversion to easy mode\n    if (criterion == '') {\n        modeCheckbox.disabled = false;\n        return;\n    }\n\n    // Value must have exactly three parts: type + comparison + tolerance (number).\n    let criterionParts = criterion.split(/\\s*(==|<)\\s*/);\n    if (criterionParts.length != 3) {\n        modeCheckbox.disabled = true;\n        return;\n    }\n\n    // Type must be _relerr or _err.\n    if (!criterionParts[0].match(/^\\s*_(rel)?err\\s*$/)) {\n        modeCheckbox.disabled = true;\n        return;\n    }\n\n    // Comparison must be == or <.\n    if (!criterionParts[1].match(/\\s*(==|<)\\s*$/)) {\n        modeCheckbox.disabled = true;\n        return;\n    }\n\n    // Tolerance must be a number.\n    let tolerance = parseFloat(criterionParts[2]);\n    // As parseFloat ignores trailing characters, we check for that separately;\n    // we just don't want the tolerance number to contain obviously invalid characters.\n    if (isNaN(tolerance) || !isFinite(tolerance) || criterionParts[2].match(/[^-+0-9.e]/)) {\n        modeCheckbox.disabled = true;\n        return;\n    }\n\n    modeCheckbox.disabled = false;\n};\n\nexport default {init};\n"],"names":["defaultCorrectness","numberOfParts","init","defCorrectness","document","querySelectorAll","length","extendTabulator","initTable","i","textfield","getElementById","form","addEventListener","reenableCriterionTextfields","blockModeSwitcherIfNeeded","bind","checkbox","handleGradingCriterionModeSwitcher","dispatchEvent","Event","disabled","classList","contains","checked","element","handleSimpleCriterionChanges","normalizeTolerance","variableFields","field","handler","validateRandomvars","validateGlobalvars","push","validateLocalvars","instantiate","extendModule","values","count","min","Infinity","max","sum","value","parseFloat","Math","isNaN","toFixed","Tabulator","selectable","movableColumns","pagination","paginationSize","paginationButtonCount","columns","title","langs","on","previewQuestionWithDataset","quoteNonNumericValue","startsWith","quotedElements","substring","split","join","fetchTextFromEditor","id","window","tinyMCE","get","getContent","row","getElement","data","getData","questionvars","partvars","Array","fill","varname","match","replace","index","parseInt","parttexts","methodname","args","questiontext","globalvars","done","showRenderedQuestionAndParts","fail","Notification","exception","div","innerHTML","question","parts","text","MathJax","version","typesetPromise","Hub","Queue","triggerMathJax","prepareTableColumns","status","firstRow","calcOptions","bottomCalc","bottomCalcFormatter","cell","getValue","columnDescription","randomColumns","randomvars","column","name","globalColumns","partColumns","partIndex","part","thisPartsColumns","vars","findTable","setColumns","fillTable","style","display","String","get_string","then","str","message","catch","allRows","rowCounter","thisRow","thisVar","partCounter","setData","howMany","localvars","answers","n","evt","target","answer","showOrClearValidationError","fieldID","annotation","innerText","remove","add","focus","partNumber","convertSimpleCriterionToText","event","tolerance","isFinite","criterionTextfield","trim","simpleCriterion","convertTextCriterionToSimple","type","comparison","typeElement","comparisonElement","toleranceElement","options","criterionParts","TypeError","indexOf","criterion","modeCheckbox"],"mappings":"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"}