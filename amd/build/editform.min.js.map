{"version":3,"file":"editform.min.js","sources":["../src/editform.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Helper functions for the form used to create / edit a formulas question.\n *\n * @module     qtype_formulas/editform\n * @copyright  2022 Philipp Imhof\n * @author     Philipp Imhof\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport * as Notification from 'core/notification';\nimport Pending from 'core/pending';\nimport {call as fetchMany} from 'core/ajax';\nimport * as Instantiation from 'qtype_formulas/instantiation';\n\n/**\n * Default grading criterion according to plugin settings (admin)\n */\nvar defaultCorrectness = '';\n\n/**\n * Number of subquestions (parts)\n */\nvar numberOfParts = 0;\n\nexport const init = (defCorrectness) => {\n    defaultCorrectness = defCorrectness;\n    numberOfParts = document.querySelectorAll('fieldset[id^=id_answerhdr_]').length;\n\n    Instantiation.init(numberOfParts);\n\n    for (let i = 0; i < numberOfParts; i++) {\n        let textfield = document.getElementById(`id_correctness_${i}`);\n\n        // Event listener for the submission of the form (attach only once)\n        if (i === 0) {\n            textfield.form.addEventListener('submit', reenableCriterionTextfields);\n        }\n\n        // Constantly check whether the current grading criterion is simple enough\n        // to allow to switch to simple mode.\n        textfield.addEventListener('input', blockModeSwitcherIfNeeded.bind(null, i));\n\n        let checkbox = document.getElementById(`id_correctness_simple_mode_${i}`);\n        checkbox.addEventListener('click', handleGradingCriterionModeSwitcher.bind(null, i));\n\n        // Trigger input event in criterion textfields in order to disable the mode switcher\n        // checkbox, if needed. If the criterion is simple enough, start with simple mode,\n        // unless the form comes back from validation and the textfield is marked as invalid.\n        textfield.dispatchEvent(new Event('input'));\n        if (!checkbox.disabled && !textfield.classList.contains('is-invalid')) {\n            checkbox.checked = true;\n            checkbox.dispatchEvent(new Event('click'));\n        }\n\n        // Always keep the textual form of the grading criterion in sync, because that's\n        // what is going to be submitted in the end.\n        let elements = ['type', 'comp', 'tol'];\n        for (let element of elements) {\n            document.getElementById(`id_correctness_simple_${element}_${i}`).addEventListener(\n                'change', handleSimpleCriterionChanges.bind(null, i)\n            );\n        }\n        document.getElementById(`id_correctness_simple_tol_${i}`).addEventListener(\n            'change', normalizeTolerance\n        );\n    }\n\n    // When the form fields for random, global or any part's local variables loses focus,\n    // have them validated by the backend. We don't use the 'change' event, because we want\n    // the content re-validated, even if there is no change. This is to capture some edge\n    // cases where there is an error in both random and global variables. The validation will\n    // fail for random and cannot check the globals. Now, if the user fixes the error in random\n    // and enters globals, we should have a new validation on blurring, even if there was no change.\n    let variableFields = [{field: 'random', handler: validateRandomvars}, {field: 'global', handler: validateGlobalvars}];\n    for (let i = 0; i < numberOfParts; i++) {\n        variableFields.push({field: `1_${i}`, handler: validateLocalvars.bind(null, i)});\n    }\n    for (let field of variableFields) {\n        document.getElementById(`id_vars${field.field}`).addEventListener(\n            'blur', field.handler\n        );\n    }\n\n    // Event listener for the \"instantiate\" button.\n    document.getElementById('id_instantiatebtn').addEventListener(\n        'click', Instantiation.instantiate\n    );\n};\n\n/**\n * Event handler for the global variables definition. The function will send the text to\n * the backend and try to evaluate it (together with the random variables, because global\n * variables can be based on random variables). If there is an error, it will be shown\n * in the form via {@link showOrClearValidationError}.\n *\n * @param {Event} evt Event object\n */\nconst validateGlobalvars = async(evt) => {\n    // We don't validate an empty field. But if there is an error from earlier validation,\n    // we must make sure it is removed.\n    if (evt.target.value === '') {\n        showOrClearValidationError(evt.target.id, '');\n        return;\n    }\n    let pendingPromise = new Pending('qtype_formulas/validateglobal');\n    try {\n        let validationResult = await fetchMany([{\n            methodname: 'qtype_formulas_check_random_global_vars',\n            args: {\n                randomvars: document.getElementById('id_varsrandom').value,\n                globalvars: evt.target.value\n            },\n        }])[0];\n        if (validationResult.source === '' || validationResult.source === 'global') {\n            showOrClearValidationError(evt.target.id, validationResult.message);\n        } else {\n            showOrClearValidationError('id_varsrandom', validationResult.message, false);\n        }\n    } catch (err) {\n        Notification.exception(err);\n    }\n    pendingPromise.resolve();\n};\n\n/**\n * Event handler for the random variables definition. The function will send the text to\n * the backend which tries to parse it and instantiate the variables. If there is an error,\n * it will be shown in the form via {@link showOrClearValidationError}.\n *\n * @param {Event} evt Event object\n */\nconst validateRandomvars = async(evt) => {\n    // We don't validate an empty field. But if there is an error from earlier validation,\n    // we must make sure it is removed.\n    if (evt.target.value === '') {\n        showOrClearValidationError(evt.target.id, '');\n        return;\n    }\n    let pendingPromise = new Pending('qtype_formulas/validaterandom');\n    try {\n        let validationResult = await fetchMany([{\n            methodname: 'qtype_formulas_check_random_global_vars',\n            args: {\n                randomvars: evt.target.value\n            },\n        }])[0];\n        showOrClearValidationError(evt.target.id, validationResult.message);\n    } catch (err) {\n        Notification.exception(err);\n    }\n    pendingPromise.resolve();\n};\n\nconst validateLocalvars = async(part) => {\n    let fieldList = {\n        'random': 'id_varsrandom',\n        'global': 'id_varsglobal',\n        'local': `id_vars1_${part}`\n    };\n    let target = document.getElementById(fieldList.local);\n    // We don't validate an empty field. But if there is an error from earlier validation,\n    // we must make sure it is removed.\n    if (target.value === '') {\n        showOrClearValidationError(target.id, '');\n        return;\n    }\n    let pendingPromise = new Pending('qtype_formulas/validatelocal');\n    try {\n        let validationResult = await fetchMany([{\n            methodname: 'qtype_formulas_check_local_vars',\n            args: {\n                randomvars: document.getElementById(fieldList.random).value,\n                globalvars: document.getElementById(fieldList.global).value,\n                localvars: target.value\n            }\n        }])[0];\n        if (validationResult.source === '') {\n            validationResult.source = 'local';\n        }\n        showOrClearValidationError(\n            fieldList[validationResult.source],\n            validationResult.message,\n            validationResult.source === 'local'\n        );\n    } catch (err) {\n        Notification.exception(err);\n    }\n    pendingPromise.resolve();\n};\n\n/**\n * Show a validation error below the corresponding form field and set the field\n * as invalid. Or remove message and marking, if there is no error anymore.\n *\n * @param {string} fieldID id of the form field to which the error belongs\n * @param {string} message error message or empty string, if error is to be removed\n * @param {boolean} sameField did the error occur in the field that was originally validated\n */\nconst showOrClearValidationError = (fieldID, message, sameField = true) => {\n    let field = document.getElementById(fieldID);\n    let annotation = document.getElementById(fieldID.replace(/^id_(.*)$/, 'id_error_$1'));\n    let alreadyWithError = (annotation.innerText.trim() !== '');\n    if (message === '') {\n        annotation.innerText = '';\n        field.classList.remove('is-invalid');\n        return;\n    }\n    annotation.innerText = message;\n    field.classList.add('is-invalid');\n    // If there is already an error in *this* field, we don't generally force the focus,\n    // because that could trap the user. We do, however, set the focus, if the prior error\n    // occured in another field.\n    if (!alreadyWithError || !sameField) {\n        field.focus();\n    }\n};\n\n/**\n * The textfields containing the grading criterion might be disabled. However, as disabled elements\n * do not submit their value, they have to be enabled before submitting the form.\n */\nconst reenableCriterionTextfields = () => {\n    for (let i = 0; i < numberOfParts; i++) {\n        document.getElementById(`id_correctness_${i}`).disabled = false;\n    }\n};\n\n/**\n * Handle change event for the elements that allow simplified entry of the grading criterion.\n * On each modification, the current criterion is propagated to the (hidden) textbox,\n * that will be used to store the criterion in the database upon submission of the form.\n * @param {number} partNumber number of the part\n */\nconst handleSimpleCriterionChanges = (partNumber) => {\n    let textbox = document.getElementById(`id_correctness_${partNumber}`);\n    textbox.value = convertSimpleCriterionToText(partNumber);\n};\n\n/**\n * Parse the tolerance value into a number and put the value back into the textfield.\n * This allows for immediate simplification and some validation; invalid numbers will be replaced by 0.\n * @param {Event} event Event containing the textfield to be normalized\n */\nconst normalizeTolerance = (event) => {\n    let field = event.target;\n    let tolerance = parseFloat(field.value);\n\n    if (isNaN(tolerance) || !isFinite(tolerance)) {\n        tolerance = 0;\n    }\n\n    field.value = tolerance;\n};\n\n/**\n * Switch between simplified and normal entry mode for the grading criterion.\n * @param {number} partNumber number of the part\n */\nconst handleGradingCriterionModeSwitcher = (partNumber) => {\n    let checkbox = document.getElementById(`id_correctness_simple_mode_${partNumber}`);\n\n    let criterionTextfield = document.getElementById(`id_correctness_${partNumber}`);\n\n    // If not checked anymore, activate expert mode --> convert settings to string and set textfield.\n    if (!checkbox.checked) {\n        criterionTextfield.value = convertSimpleCriterionToText(partNumber);\n        return;\n    }\n\n    // Activate simple mode. If input field is empty, use default value.\n    if (criterionTextfield.value.trim() == '') {\n        criterionTextfield.value = defaultCorrectness;\n    }\n\n    let simpleCriterion = convertTextCriterionToSimple(partNumber);\n    document.getElementById(`id_correctness_simple_type_${partNumber}`).value = simpleCriterion.type;\n    document.getElementById(`id_correctness_simple_comp_${partNumber}`).value = simpleCriterion.comparison;\n    document.getElementById(`id_correctness_simple_tol_${partNumber}`).value = simpleCriterion.tolerance;\n};\n\n/**\n * Convert the simple grading criterion into the corresponding text.\n * @param {number} partNumber number of the part\n * @returns {string} text form of the grading criterion\n */\nconst convertSimpleCriterionToText = (partNumber) => {\n    let typeElement = document.getElementById(`id_correctness_simple_type_${partNumber}`);\n    let comparisonElement = document.getElementById(`id_correctness_simple_comp_${partNumber}`);\n    let toleranceElement = document.getElementById(`id_correctness_simple_tol_${partNumber}`);\n\n    return ['_relerr', '_err'][typeElement.value] + ' '\n        + comparisonElement.options[comparisonElement.value].innerText + ' '\n        + parseFloat(toleranceElement.value);\n};\n\n/**\n * Convert the grading criterion into the simplified form.\n * @param {number} partNumber number of the part\n * @returns {object} criterion the simplified grading criterion\n * @returns {number} criterion.type the type of error (relative or absolute)\n * @returns {number} criterion.comparison the comparison (== or <)\n * @returns {number} criteron.tolerance the tolerance value\n * @throws {TypeError} throws if the value cannot be converted\n */\nconst convertTextCriterionToSimple = (partNumber) => {\n    // Split input into its parts (type, comparison, tolerance).\n    let criterionParts = document.getElementById(`id_correctness_${partNumber}`).value.split(/\\s*(==|<)\\s*/);\n\n    // This should not happen, but it might be better to check anyway.\n    if (criterionParts.length != 3 || !criterionParts[0].match(/^\\s*_(rel)?err\\s*$/)) {\n        throw new TypeError('The given grading criterion cannot be shown in simple mode.');\n    }\n\n    return {\n        'type': ['_relerr', '_err'].indexOf(criterionParts[0]),\n        'comparison': ['==', '<'].indexOf(criterionParts[1]),\n        'tolerance': parseFloat(criterionParts[2])\n    };\n};\n\n/**\n * Check whether the current grading criterion can be converted into the simplified form.\n * If not, disable the checkbox that would allow switching to simple mode.\n * If yes, enable sais checkbox.\n * If the text box is empty, conversion is possible using the default value.\n * @param {number} partNumber number of the part\n */\nconst blockModeSwitcherIfNeeded = (partNumber) => {\n    let criterion = document.getElementById(`id_correctness_${partNumber}`).value.trim();\n    let modeCheckbox = document.getElementById(`id_correctness_simple_mode_${partNumber}`);\n    // If textfield is empty, allow conversion to easy mode\n    if (criterion == '') {\n        modeCheckbox.disabled = false;\n        return;\n    }\n\n    // Value must have exactly three parts: type + comparison + tolerance (number).\n    let criterionParts = criterion.split(/\\s*(==|<)\\s*/);\n    if (criterionParts.length != 3) {\n        modeCheckbox.disabled = true;\n        return;\n    }\n\n    // Type must be _relerr or _err.\n    if (!criterionParts[0].match(/^\\s*_(rel)?err\\s*$/)) {\n        modeCheckbox.disabled = true;\n        return;\n    }\n\n    // Comparison must be == or <.\n    if (!criterionParts[1].match(/\\s*(==|<)\\s*$/)) {\n        modeCheckbox.disabled = true;\n        return;\n    }\n\n    // Tolerance must be a number.\n    let tolerance = parseFloat(criterionParts[2]);\n    // As parseFloat ignores trailing characters, we check for that separately;\n    // we just don't want the tolerance number to contain obviously invalid characters.\n    if (isNaN(tolerance) || !isFinite(tolerance) || criterionParts[2].match(/[^-+0-9.e]/)) {\n        modeCheckbox.disabled = true;\n        return;\n    }\n\n    modeCheckbox.disabled = false;\n};\n\nexport default {init};\n"],"names":["defaultCorrectness","numberOfParts","init","defCorrectness","document","querySelectorAll","length","Instantiation","i","textfield","getElementById","form","addEventListener","reenableCriterionTextfields","blockModeSwitcherIfNeeded","bind","checkbox","handleGradingCriterionModeSwitcher","dispatchEvent","Event","disabled","classList","contains","checked","element","handleSimpleCriterionChanges","normalizeTolerance","variableFields","field","handler","validateRandomvars","validateGlobalvars","push","validateLocalvars","instantiate","evt","target","value","showOrClearValidationError","id","pendingPromise","Pending","methodname","args","randomvars","globalvars","validationResult","source","message","Notification","exception","resolve","part","fieldList","local","random","global","localvars","fieldID","sameField","annotation","replace","alreadyWithError","innerText","trim","remove","add","focus","partNumber","convertSimpleCriterionToText","event","tolerance","parseFloat","isNaN","isFinite","criterionTextfield","simpleCriterion","convertTextCriterionToSimple","type","comparison","typeElement","comparisonElement","toleranceElement","options","criterionParts","split","match","TypeError","indexOf","criterion","modeCheckbox"],"mappings":"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"}