{"version":3,"file":"editform.min.js","sources":["../src/editform.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Helper functions for the form used to create / edit a formulas question.\n *\n * @module     qtype_formulas/editform\n * @copyright  2022 Philipp Imhof\n * @author     Philipp Imhof\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport * as Notification from 'core/notification';\nimport {call as fetchMany} from 'core/ajax';\nimport {TabulatorFull as Tabulator} from 'qtype_formulas/tabulator';\n\n/**\n * Default grading criterion according to plugin settings (admin)\n */\nvar defaultCorrectness = '';\n\n/**\n * Number of subquestions (parts)\n */\nvar numberOfParts = 0;\n\nexport const init = (defCorrectness) => {\n    Tabulator.extendModule('columnCalcs', 'calculations', {\n        'myavg': (values) => {\n            var count = 0;\n            var sum = 0;\n\n            for (let value of values) {\n                sum += parseFloat(value);\n                count++;\n            }\n\n            if (count > 0 && !isNaN(sum)) {\n                return (sum / count).toFixed(1);\n            }\n            return '';\n        },\n        'avglabel': () => {\n            return '⌀';\n        }\n    });\n    let table = new Tabulator('#varsdata_display', {\n        selectable: 1,\n        movableColumns: true,\n        pagination: 'local',\n        paginationSize: 10,\n        paginationButtonCount: 0,\n        columns: [\n            {title: '#', field: 'id', bottomCalc: 'avglabel'},\n        ],\n        langs: {\n            'default': {\n                'pagination': {\n                    'first': '⏮',\n                    'last': '⏭',\n                    'prev': '⏪',\n                    'next': '⏩'\n                }\n            }\n        },\n    });\n    table.on('rowSelected', previewQuestionWithDataset);\n    defaultCorrectness = defCorrectness;\n    numberOfParts = document.querySelectorAll('fieldset[id^=id_answerhdr_]').length;\n\n    for (let i = 0; i < numberOfParts; i++) {\n        let textfield = document.getElementById(`id_correctness_${i}`);\n        // Constantly check whether the current grading criterion is simple enough\n        // to allow to switch to simple mode.\n        textfield.addEventListener('input', blockModeSwitcherIfNeeded.bind(null, i));\n\n        // Event listener for the submission of the form (attach only once)\n        if (i === 0) {\n            textfield.form.addEventListener('submit', reenableCriterionTextfields);\n        }\n\n        let checkbox = document.getElementById(`id_correctness_simple_mode_${i}`);\n        checkbox.addEventListener('click', handleGradingCriterionModeSwitcher.bind(null, i));\n\n        // Trigger input event in criterion textfields in order to disable the mode switcher\n        // checkbox, if needed. If the criterion is simple enough, start with simple mode,\n        // unless the form comes back from validation and the textfield is marked as invalid.\n        textfield.dispatchEvent(new Event('input'));\n        if (!checkbox.disabled && !textfield.classList.contains('is-invalid')) {\n            checkbox.checked = true;\n            checkbox.dispatchEvent(new Event('click'));\n        }\n\n        // Always keep the textual form of the grading criterion in sync, because that's\n        // what is going to be submitted in the end.\n        document.getElementById(`id_correctness_simple_type_${i}`).addEventListener(\n            'change', handleSimpleCriterionChanges.bind(null, i)\n        );\n        document.getElementById(`id_correctness_simple_comp_${i}`).addEventListener(\n            'change', handleSimpleCriterionChanges.bind(null, i)\n        );\n        document.getElementById(`id_correctness_simple_tol_${i}`).addEventListener(\n            'change', handleSimpleCriterionChanges.bind(null, i)\n        );\n        document.getElementById(`id_correctness_simple_tol_${i}`).addEventListener(\n            'change', normalizeTolerance\n        );\n    }\n\n    document.getElementById('id_varsrandom').addEventListener(\n        'change', validateRandomvars\n    );\n    document.getElementById('id_varsglobal').addEventListener(\n        'change', validateGlobalvars\n    );\n    document.getElementById('id_instantiatebtn').addEventListener(\n        'click', instantiate\n    );\n};\n\n/**\n * For proper parsing in the backend, strings must be enclosed in double quotes,\n * but numbers must not.\n *\n * @param {string} value representation of a numberic, string or list (array) value\n * @returns {string} the same value, but with quotes added, if necessary\n */\nconst quoteNonNumericValue = (value) => {\n    // Numbers must not be quoted.\n    if (!isNaN(value)) {\n        return value;\n    }\n    // For arrays, we have to check each element individually and quote, if necessary.\n    // Formulas question does not currently support nested arrays, so we don't have to deal with that.\n    if (value.startsWith('[')) {\n        let quotedElements = [];\n        // Remove leading and trailing bracket\n        value = value.substring(1, value.length - 1);\n        let elements = value.split(/\\s*,\\s*/);\n        for (let element of elements) {\n            quotedElements.push(quoteNonNumericValue(element));\n        }\n        return '[' + quotedElements.join(', ') + ']';\n    }\n    // Not a number and not an array, so we enclose it in double quotes.\n    return `\"${value}\"`;\n};\n\n/**\n * The question text and the parts' text are stored in the editor. For some editors,\n * we can take the content from the textarea's value attribute. For TinyMCE (and maybe others),\n * we must use the corresponding API.\n *\n * @param {string} id id of the textarea\n * @returns {string} the question or part's text\n */\nconst fetchTextFromEditor = (id) => {\n    if (typeof window.tinyMCE !== 'undefined') {\n        return window.tinyMCE.get(id).getContent();\n    }\n    return document.getElementById(id).value;\n};\n\n/**\n * Extract data from the instantiation table (selected row) and send them to the backend,\n * in order to have the question text and parts' text rendered for the preview.\n *\n * @param {object} row RowComponent from Tabulator.js\n */\nconst previewQuestionWithDataset = (row) => {\n    let data = row.getData();\n    let questionvars = '';\n    let partvars = Array(numberOfParts).fill('');\n\n    for (let varname in data) {\n        // Variables for the main question are all random or global.\n        // Also, as random variables have already been instantiated, they are not random anymore.\n        if (varname.match(/^(random|global)_/)) {\n            questionvars += varname.replace(/^(random|global)_([^*]+)\\*?$/, '$2') + '=';\n            questionvars += quoteNonNumericValue(data[varname]) + ';';\n        }\n        // Variables for a question part always start with part_ + number of the part\n        if (varname.match(/^part_(\\d+)_/)) {\n            // If the variable name starts with _ it should be removed, as these are\n            // answers (or otherwise reserved names, but that should not be the case)\n            if (varname.match(/^part_(\\d+)__/)) {\n                continue;\n            }\n            let index = parseInt(varname.replace(/^part_(\\d+)_.*$/, '$1'));\n            partvars[index] += varname.replace(/^part_(\\d+)_([^*]+)\\*?$/, '$2') + '=';\n            partvars[index] += quoteNonNumericValue(data[varname]) + ';';\n        }\n    }\n\n    let parttexts = [];\n    for (let i = 0; i < numberOfParts; i++) {\n        parttexts[i] = fetchTextFromEditor(`id_subqtext_${i}`);\n    }\n\n    fetchMany([{\n        methodname: 'qtype_formulas_render_question_text',\n        args: {\n            questiontext: fetchTextFromEditor('id_questiontext'),\n            parttexts: parttexts,\n            globalvars: questionvars,\n            partvars: partvars\n        },\n        done: showRenderedQuestionAndParts,\n        fail: Notification.exception\n    }]);\n};\n\n/**\n * This function is called after the AJAX request to the backend is completed. It will inject\n * the rendered texts into the preview div.\n *\n * @param {object} data rendered version of question text and parts' text\n */\nconst showRenderedQuestionAndParts = (data) => {\n    let div = document.getElementById('qtextpreview_display');\n    div.innerHTML = data.question;\n    for (let text of data.parts) {\n        div.innerHTML += text;\n    }\n};\n\n/**\n * Derive the column description from the instantiated variables.\n *\n * @param {object} data instantiation data as received from the backend\n * @returns {object} column description object for Tabulator.js\n */\nconst prepareTableColumns = (data) => {\n    let firstRow = data.data[0];\n    // Random variables come first\n    let randomColumns = [];\n    for (let column of firstRow.randomvars) {\n        randomColumns.push({title: column.name, field: `random_${column.name}`, bottomCalc: 'myavg'});\n    }\n\n    // Then we take the global variables\n    let globalColumns = [];\n    for (let column of firstRow.globalvars) {\n        globalColumns.push({title: column.name, field: `global_${column.name}`, bottomCalc: 'myavg'});\n    }\n\n    // Finally, we prepare the groups for each part\n    let partColumns = [];\n    let partIndex = 0;\n    for (let part of firstRow.parts) {\n        let thisPartsColumns = [];\n        for (let vars of part) {\n            thisPartsColumns.push({title: vars.name, field: `part_${partIndex}_${vars.name}`, bottomCalc: 'myavg'});\n        }\n        partColumns.push({title: `part ${partIndex + 1}`, columns: thisPartsColumns});\n        partIndex++;\n    }\n\n    // Now, put it all together\n    let columnDescription = [\n        {title: '#', field: 'id'},\n        {title: 'random variables', columns: randomColumns},\n        {title: 'global variables', columns: globalColumns},\n        ...partColumns\n    ];\n    Tabulator.findTable(\"#varsdata_display\")[0].setColumns(columnDescription);\n    fillTable(data);\n    return columnDescription;\n};\n\n/**\n * Prepare the data and send it to the Tabulator.js table for display.\n *\n * @param {object} data instantiation data as received from the backend\n */\nconst fillTable = (data) => {\n    let allRows = [];\n    let rowCounter = 0;\n    for (let row of data.data) {\n        let thisRow = {id: ++rowCounter};\n        for (let thisVar of row.randomvars) {\n            thisRow[`random_${thisVar.name}`] = thisVar.value;\n        }\n        for (let thisVar of row.globalvars) {\n            thisRow[`global_${thisVar.name}`] = thisVar.value;\n        }\n        let partCounter = 0;\n        for (let thisPart of row.parts) {\n            for (let thisVar of thisPart) {\n                thisRow[`part_${partCounter}_${thisVar.name}`] = thisVar.value;\n            }\n            partCounter++;\n        }\n        allRows.push(thisRow);\n    }\n\n    Tabulator.findTable(\"#varsdata_display\")[0].setData(allRows);\n};\n\n/**\n * Send the definition of random variables, global variables and parts' local variables\n * to the backend for instantiation. This will generate a certain number of rows, based\n * on the number the user has selected in the corresponding dropdown field. Once the\n * AJAX requeset is completed, the data will be forwarded to {@link prepareTableColumns}.\n */\nconst instantiate = () => {\n    let howMany = document.getElementById('id_numdataset').value;\n    fetchMany([{\n        methodname: 'qtype_formulas_instantiate',\n        args: {\n            n: howMany,\n            randomvars: document.getElementById('id_varsrandom').value,\n            globalvars: document.getElementById('id_varsglobal').value,\n            localvars: [\n                document.getElementById('id_vars1_0').value,\n                document.getElementById('id_vars1_1').value,\n                document.getElementById('id_vars1_2').value,\n            ],\n            answers: [\n                document.getElementById('id_answer_0').value,\n                document.getElementById('id_answer_1').value,\n                document.getElementById('id_answer_2').value,\n            ]\n        },\n        done: prepareTableColumns,\n        fail: Notification.exception\n    }]);\n};\n\n/**\n * Event handler for the global variables definition. The function will send the text to\n * the backend and try to evaluate it (together with the random variables, because global\n * variables can be based on random variables). If there is an error, it will be shown\n * in the form via {@link showOrClearValidationError}.\n *\n * @param {Event} evt Event object\n */\nconst validateGlobalvars = (evt) => {\n    fetchMany([{\n        methodname: 'qtype_formulas_check_random_global_vars',\n        args: {\n            randomvars: document.getElementById('id_varsrandom').value,\n            globalvars: evt.target.value\n        },\n        done: (answer) => {\n            showOrClearValidationError(evt.target.id, answer);\n        },\n        fail: Notification.exception\n    }]);\n};\n\n/**\n * Event handler for the random variables definition. The function will send the text to\n * the backend which tries to parse it and instantiate the variables. If there is an error,\n * it will be shown in the form via {@link showOrClearValidationError}.\n *\n * @param {Event} evt Event object\n */\nconst validateRandomvars = (evt) => {\n    fetchMany([{\n        methodname: 'qtype_formulas_check_random_global_vars',\n        args: {\n            randomvars: evt.target.value\n        },\n        done: (answer) => {\n            showOrClearValidationError(evt.target.id, answer);\n        },\n        fail: Notification.exception\n    }]);\n};\n\n/**\n * Show a validation error below the corresponding form field and set the field\n * as invalid. Or remove message and marking, if there is no error anymore.\n *\n * @param {string} fieldID id of the form field to which the error belongs\n * @param {string} message error message or empty string, if error is to be removed\n */\nconst showOrClearValidationError = (fieldID, message) => {\n    let field = document.getElementById(fieldID);\n    let annotation = document.getElementById(fieldID.replace(/^id_(.*)$/, 'id_error_$1'));\n    if (message === '') {\n        annotation.innerText = '';\n        field.classList.remove('is-invalid');\n    } else {\n        annotation.innerText = message;\n        field.classList.add('is-invalid');\n        field.focus();\n    }\n};\n\n/**\n * The textfields containing the grading criterion might be disabled. However, as disabled elements\n * do not submit their value, they have to be enabled before submitting the form.\n */\nconst reenableCriterionTextfields = () => {\n    for (let i = 0; i < numberOfParts; i++) {\n        document.getElementById(`id_correctness_${i}`).disabled = false;\n    }\n};\n\n/**\n * Handle change event for the elements that allow simplified entry of the grading criterion.\n * On each modification, the current criterion is propagated to the (hidden) textbox,\n * that will be used to store the criterion in the database upon submission of the form.\n * @param {number} partNumber number of the part\n */\nconst handleSimpleCriterionChanges = (partNumber) => {\n    let textbox = document.getElementById(`id_correctness_${partNumber}`);\n    textbox.value = convertSimpleCriterionToText(partNumber);\n};\n\n/**\n * Parse the tolerance value into a number and put the value back into the textfield.\n * This allows for immediate simplification and some validation; invalid numbers will be replaced by 0.\n * @param {Event} event Event containing the textfield to be normalized\n */\nconst normalizeTolerance = (event) => {\n    let field = event.target;\n    let tolerance = parseFloat(field.value);\n\n    if (isNaN(tolerance) || !isFinite(tolerance)) {\n        tolerance = 0;\n    }\n\n    field.value = tolerance;\n};\n\n/**\n * Switch between simplified and normal entry mode for the grading criterion.\n * @param {number} partNumber number of the part\n */\nconst handleGradingCriterionModeSwitcher = (partNumber) => {\n    let checkbox = document.getElementById(`id_correctness_simple_mode_${partNumber}`);\n\n    let criterionTextfield = document.getElementById(`id_correctness_${partNumber}`);\n\n    // If not checked anymore, activate expert mode --> convert settings to string and set textfield.\n    if (!checkbox.checked) {\n        criterionTextfield.value = convertSimpleCriterionToText(partNumber);\n        return;\n    }\n\n    // Activate simple mode. If input field is empty, use default value.\n    if (criterionTextfield.value.trim() == '') {\n        criterionTextfield.value = defaultCorrectness;\n    }\n\n    let simpleCriterion = convertTextCriterionToSimple(partNumber);\n    document.getElementById(`id_correctness_simple_type_${partNumber}`).value = simpleCriterion.type;\n    document.getElementById(`id_correctness_simple_comp_${partNumber}`).value = simpleCriterion.comparison;\n    document.getElementById(`id_correctness_simple_tol_${partNumber}`).value = simpleCriterion.tolerance;\n};\n\n/**\n * Convert the simple grading criterion into the corresponding text.\n * @param {number} partNumber number of the part\n * @returns {string} text form of the grading criterion\n */\nconst convertSimpleCriterionToText = (partNumber) => {\n    let typeElement = document.getElementById(`id_correctness_simple_type_${partNumber}`);\n    let comparisonElement = document.getElementById(`id_correctness_simple_comp_${partNumber}`);\n    let toleranceElement = document.getElementById(`id_correctness_simple_tol_${partNumber}`);\n\n    return ['_relerr', '_err'][typeElement.value] + ' '\n        + comparisonElement.options[comparisonElement.value].innerText + ' '\n        + parseFloat(toleranceElement.value);\n};\n\n/**\n * Convert the grading criterion into the simplified form.\n * @param {number} partNumber number of the part\n * @returns {object} criterion the simplified grading criterion\n * @returns {number} criterion.type the type of error (relative or absolute)\n * @returns {number} criterion.comparison the comparison (== or <)\n * @returns {number} criteron.tolerance the tolerance value\n * @throws {TypeError} throws if the value cannot be converted\n */\nconst convertTextCriterionToSimple = (partNumber) => {\n    // Split input into its parts (type, comparison, tolerance).\n    let criterionParts = document.getElementById(`id_correctness_${partNumber}`).value.split(/\\s*(==|<)\\s*/);\n\n    // This should not happen, but it might be better to check anyway.\n    if (criterionParts.length != 3 || !criterionParts[0].match(/^\\s*_(rel)?err\\s*$/)) {\n        throw new TypeError('The given grading criterion cannot be shown in simple mode.');\n    }\n\n    return {\n        'type': ['_relerr', '_err'].indexOf(criterionParts[0]),\n        'comparison': ['==', '<'].indexOf(criterionParts[1]),\n        'tolerance': parseFloat(criterionParts[2])\n    };\n};\n\n/**\n * Check whether the current grading criterion can be converted into the simplified form.\n * If not, disable the checkbox that would allow switching to simple mode.\n * If yes, enable sais checkbox.\n * If the text box is empty, conversion is possible using the default value.\n * @param {number} partNumber number of the part\n */\nconst blockModeSwitcherIfNeeded = (partNumber) => {\n    let criterion = document.getElementById(`id_correctness_${partNumber}`).value.trim();\n    let modeCheckbox = document.getElementById(`id_correctness_simple_mode_${partNumber}`);\n    // If textfield is empty, allow conversion to easy mode\n    if (criterion == '') {\n        modeCheckbox.disabled = false;\n        return;\n    }\n\n    // Value must have exactly three parts: type + comparison + tolerance (number).\n    let criterionParts = criterion.split(/\\s*(==|<)\\s*/);\n    if (criterionParts.length != 3) {\n        modeCheckbox.disabled = true;\n        return;\n    }\n\n    // Type must be _relerr or _err.\n    if (!criterionParts[0].match(/^\\s*_(rel)?err\\s*$/)) {\n        modeCheckbox.disabled = true;\n        return;\n    }\n\n    // Comparison must be == or <.\n    if (!criterionParts[1].match(/\\s*(==|<)\\s*$/)) {\n        modeCheckbox.disabled = true;\n        return;\n    }\n\n    // Tolerance must be a number.\n    let tolerance = parseFloat(criterionParts[2]);\n    // As parseFloat ignores trailing characters, we check for that separately;\n    // we just don't want the tolerance number to contain obviously invalid characters.\n    if (isNaN(tolerance) || !isFinite(tolerance) || criterionParts[2].match(/[^-+0-9.e]/)) {\n        modeCheckbox.disabled = true;\n        return;\n    }\n\n    modeCheckbox.disabled = false;\n};\n\nexport default {init};\n"],"names":["defaultCorrectness","numberOfParts","init","defCorrectness","extendModule","values","count","sum","value","parseFloat","isNaN","toFixed","Tabulator","selectable","movableColumns","pagination","paginationSize","paginationButtonCount","columns","title","field","bottomCalc","langs","on","previewQuestionWithDataset","document","querySelectorAll","length","i","textfield","getElementById","addEventListener","blockModeSwitcherIfNeeded","bind","form","reenableCriterionTextfields","checkbox","handleGradingCriterionModeSwitcher","dispatchEvent","Event","disabled","classList","contains","checked","handleSimpleCriterionChanges","normalizeTolerance","validateRandomvars","validateGlobalvars","instantiate","quoteNonNumericValue","startsWith","quotedElements","substring","split","element","push","join","fetchTextFromEditor","id","window","tinyMCE","get","getContent","row","data","getData","questionvars","partvars","Array","fill","varname","match","replace","index","parseInt","parttexts","methodname","args","questiontext","globalvars","done","showRenderedQuestionAndParts","fail","Notification","exception","div","innerHTML","question","parts","text","prepareTableColumns","firstRow","randomColumns","randomvars","column","name","globalColumns","partColumns","partIndex","part","thisPartsColumns","vars","columnDescription","findTable","setColumns","fillTable","allRows","rowCounter","thisRow","thisVar","partCounter","setData","howMany","n","localvars","answers","evt","target","answer","showOrClearValidationError","fieldID","message","annotation","innerText","remove","add","focus","partNumber","convertSimpleCriterionToText","event","tolerance","isFinite","criterionTextfield","trim","simpleCriterion","convertTextCriterionToSimple","type","comparison","typeElement","comparisonElement","toleranceElement","options","criterionParts","TypeError","indexOf","criterion","modeCheckbox"],"mappings":"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"}