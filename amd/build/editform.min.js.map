{"version":3,"file":"editform.min.js","sources":["../src/editform.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Helper functions for the form used to create / edit a formulas question.\n *\n * @module     qtype_formulas/editform\n * @copyright  2022 Philipp Imhof\n * @author     Philipp Imhof\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport * as Notification from 'core/notification';\nimport * as String from 'core/str';\nimport Pending from 'core/pending';\nimport {call as fetchMany} from 'core/ajax';\nimport {TabulatorFull as Tabulator} from 'qtype_formulas/tabulator';\n\n/**\n * Default grading criterion according to plugin settings (admin)\n */\nvar defaultCorrectness = '';\n\n/**\n * Number of subquestions (parts)\n */\nvar numberOfParts = 0;\n\nexport const init = (defCorrectness) => {\n    defaultCorrectness = defCorrectness;\n    numberOfParts = document.querySelectorAll('fieldset[id^=id_answerhdr_]').length;\n\n    extendTabulator();\n    initTable();\n\n    for (let i = 0; i < numberOfParts; i++) {\n        let textfield = document.getElementById(`id_correctness_${i}`);\n\n        // Event listener for the submission of the form (attach only once)\n        if (i === 0) {\n            textfield.form.addEventListener('submit', reenableCriterionTextfields);\n        }\n\n        // Constantly check whether the current grading criterion is simple enough\n        // to allow to switch to simple mode.\n        textfield.addEventListener('input', blockModeSwitcherIfNeeded.bind(null, i));\n\n        let checkbox = document.getElementById(`id_correctness_simple_mode_${i}`);\n        checkbox.addEventListener('click', handleGradingCriterionModeSwitcher.bind(null, i));\n\n        // Trigger input event in criterion textfields in order to disable the mode switcher\n        // checkbox, if needed. If the criterion is simple enough, start with simple mode,\n        // unless the form comes back from validation and the textfield is marked as invalid.\n        textfield.dispatchEvent(new Event('input'));\n        if (!checkbox.disabled && !textfield.classList.contains('is-invalid')) {\n            checkbox.checked = true;\n            checkbox.dispatchEvent(new Event('click'));\n        }\n\n        // Always keep the textual form of the grading criterion in sync, because that's\n        // what is going to be submitted in the end.\n        let elements = ['type', 'comp', 'tol'];\n        for (let element of elements) {\n            document.getElementById(`id_correctness_simple_${element}_${i}`).addEventListener(\n                'change', handleSimpleCriterionChanges.bind(null, i)\n            );\n        }\n        document.getElementById(`id_correctness_simple_tol_${i}`).addEventListener(\n            'change', normalizeTolerance\n        );\n    }\n\n    // When the definition of random, global or any part's local variables is changed,\n    // have them validated by the backend.\n    let variableFields = [{field: 'random', handler: validateRandomvars}, {field: 'global', handler: validateGlobalvars}];\n    for (let i = 0; i < numberOfParts; i++) {\n        variableFields.push({field: `1_${i}`, handler: validateLocalvars.bind(null, i)});\n    }\n    for (let field of variableFields) {\n        document.getElementById(`id_vars${field.field}`).addEventListener(\n            'change', field.handler\n        );\n    }\n\n    // Event listener for the \"instantiate\" button.\n    document.getElementById('id_instantiatebtn').addEventListener(\n        'click', instantiate\n    );\n};\n\n/**\n * Add some customizations to Tabulator.js\n */\nconst extendTabulator = () => {\n    Tabulator.extendModule('columnCalcs', 'calculations', {\n        'stats': (values) => {\n            var count = 0;\n            var min = Infinity;\n            var max = -Infinity;\n            var sum = 0;\n\n            for (let value of values) {\n                sum += parseFloat(value);\n                min = Math.min(min, value);\n                max = Math.max(max, value);\n                count++;\n            }\n\n            // If minimum and maximum are the same, we don't display the stats, because\n            // the values are constant.\n            if (min === max) {\n                return ['', '', ''];\n            }\n\n            if (count > 0 && !isNaN(sum)) {\n                return [(sum / count).toFixed(1), min, max];\n            }\n            return ['', '', ''];\n        },\n    });\n};\n\n/**\n * Init the table we use for checking the variables' instantiation.\n */\nconst initTable = () => {\n    let table = new Tabulator('#varsdata_display', {\n        selectable: 1,\n        movableColumns: true,\n        pagination: 'local',\n        paginationSize: 10,\n        paginationButtonCount: 0,\n        columns: [\n            {title: '#', field: 'id'},\n        ],\n        langs: {\n            'default': {\n                'pagination': {\n                    'first': '⏮',\n                    'last': '⏭',\n                    'prev': '⏪',\n                    'next': '⏩'\n                }\n            }\n        },\n    });\n    table.on('rowSelected', previewQuestionWithDataset);\n};\n\n/**\n * For proper parsing in the backend, strings must be enclosed in double quotes,\n * but numbers must not.\n *\n * @param {string} value representation of a numberic, string or list (array) value\n * @returns {string} the same value, but with quotes added, if necessary\n */\nconst quoteNonNumericValue = (value) => {\n    // Numbers must not be quoted.\n    if (!isNaN(value)) {\n        return value;\n    }\n    // For arrays, we have to check each element individually and quote, if necessary.\n    // Formulas question does not currently support nested arrays, so we don't have to deal with that.\n    if (value.startsWith('[')) {\n        let quotedElements = [];\n        // Remove leading and trailing bracket\n        value = value.substring(1, value.length - 1);\n        let elements = value.split(/\\s*,\\s*/);\n        for (let element of elements) {\n            quotedElements.push(quoteNonNumericValue(element));\n        }\n        return '[' + quotedElements.join(', ') + ']';\n    }\n    // Not a number and not an array, so we enclose it in double quotes.\n    return `\"${value}\"`;\n};\n\n/**\n * The question text and the parts' text are stored in the editor. For some editors,\n * we can take the content from the textarea's value attribute. For TinyMCE (and maybe others),\n * we must use the corresponding API.\n *\n * @param {string} id id of the textarea\n * @returns {string} the question or part's text\n */\nconst fetchTextFromEditor = (id) => {\n    if (typeof window.tinyMCE !== 'undefined' && window.tinyMCE.get(id) !== null) {\n        return window.tinyMCE.get(id).getContent();\n    }\n    return document.getElementById(id).value;\n};\n\n/**\n * Extract data from the instantiation table (selected row) and send them to the backend,\n * in order to have the question text and parts' text rendered for the preview.\n *\n * @param {object} row RowComponent from Tabulator.js\n */\nconst previewQuestionWithDataset = async(row) => {\n    // The statistics row is clickable, but we cannot use its data to preview the question.\n    if (row.getElement().classList.contains('tabulator-calcs')) {\n        return;\n    }\n    let data = row.getData();\n    let questionvars = '';\n    let partvars = Array(numberOfParts).fill('');\n\n    for (let varname in data) {\n        // Variables for the main question are all random or global.\n        // Also, as random variables have already been instantiated, they are not random anymore.\n        if (varname.match(/^(random|global)_/)) {\n            questionvars += varname.replace(/^(random|global)_([^*]+)\\*?$/, '$2') + '=';\n            questionvars += quoteNonNumericValue(data[varname]) + ';';\n        }\n        // Variables for a question part always start with part_ + number of the part\n        if (varname.match(/^part_(\\d+)_/)) {\n            // If the variable name starts with _ it should be removed, as these are\n            // answers (or otherwise reserved names, but that should not be the case)\n            if (varname.match(/^part_(\\d+)__/)) {\n                continue;\n            }\n            let index = parseInt(varname.replace(/^part_(\\d+)_.*$/, '$1'));\n            partvars[index] += varname.replace(/^part_(\\d+)_([^*]+)\\*?$/, '$2') + '=';\n            partvars[index] += quoteNonNumericValue(data[varname]) + ';';\n        }\n    }\n\n    let parttexts = [];\n    for (let i = 0; i < numberOfParts; i++) {\n        parttexts[i] = fetchTextFromEditor(`id_subqtext_${i}`);\n    }\n\n    let pendingPromise = new Pending('qtype_formulas/questionpreview');\n    try {\n        let renderedTexts = await fetchMany([{\n            methodname: 'qtype_formulas_render_question_text',\n            args: {\n                questiontext: fetchTextFromEditor('id_questiontext'),\n                parttexts: parttexts,\n                globalvars: questionvars,\n                partvars: partvars\n            }\n        }])[0];\n        showRenderedQuestionAndParts(renderedTexts);\n    } catch (err) {\n        Notification.exception(err);\n    }\n    pendingPromise.resolve();\n};\n\n/**\n * Trigger MathJax rendering for the question.\n *\n * @param {Element} element the <div> element where the question text is shown\n */\nconst triggerMathJax = (element) => {\n    if (typeof window.MathJax === 'undefined') {\n        return;\n    }\n    let version = window.MathJax.version;\n    if (version[0] == '2') {\n        window.MathJax.Hub.Queue(['Typeset', window.MathJax.Hub, element]);\n        return;\n    }\n    if (version[0] == '3') {\n        window.MathJax.typesetPromise([element]);\n    }\n};\n\n/**\n * This function is called after the AJAX request to the backend is completed. It will inject\n * the rendered texts into the preview div.\n *\n * @param {object} data rendered version of question text and parts' text\n */\nconst showRenderedQuestionAndParts = (data) => {\n    let div = document.getElementById('qtextpreview_display');\n    div.innerHTML = data.question;\n    for (let text of data.parts) {\n        div.innerHTML += text;\n    }\n    triggerMathJax(div);\n};\n\n/**\n * Derive the column description from the instantiated variables.\n *\n * @param {object} data instantiation data as received from the backend\n */\nconst prepareTableColumns = (data) => {\n    let firstRow = data[0];\n    let calcOptions = {bottomCalc: 'stats', bottomCalcFormatter: (cell) => cell.getValue().join('<br>')};\n    let columnDescription = [{title: '#', field: 'id', bottomCalcFormatter: () => '⌀<br>min</br>max'}];\n\n    // Random variables come first\n    let randomColumns = [];\n    for (let column of firstRow.randomvars) {\n        randomColumns.push({\n            title: column.name,\n            field: `random_${column.name}`,\n            ...calcOptions\n        });\n    }\n    if (randomColumns.length > 0) {\n        columnDescription.push({title: 'Random variables', columns: randomColumns});\n    }\n\n    // Then we take the global variables\n    let globalColumns = [];\n    for (let column of firstRow.globalvars) {\n        globalColumns.push({\n            title: column.name,\n            field: `global_${column.name}`,\n            ...calcOptions\n        });\n    }\n    if (globalColumns.length > 0) {\n        columnDescription.push({title: 'Global variables', columns: globalColumns});\n    }\n\n    // Finally, we prepare the groups for each part\n    let partColumns = [];\n    let partIndex = 0;\n    for (let part of firstRow.parts) {\n        let thisPartsColumns = [];\n        for (let vars of part) {\n            thisPartsColumns.push({\n                title: vars.name,\n                field: `part_${partIndex}_${vars.name}`,\n                ...calcOptions\n            });\n        }\n        partColumns.push({title: `Part ${partIndex + 1}`, columns: thisPartsColumns});\n        partIndex++;\n    }\n    columnDescription = [...columnDescription, ...partColumns];\n    Tabulator.findTable(\"#varsdata_display\")[0].setColumns(columnDescription);\n    fillTable(data);\n\n    // We do not show the calculation row in the footer if there's just one data set.\n    let holders = document.querySelectorAll('div.tabulator-calcs-holder');\n    for (let holder of holders) {\n        holder.style.display = (data.length > 1 ? 'block' : 'none');\n    }\n};\n\n/**\n * Prepare the data and send it to the Tabulator.js table for display.\n *\n * @param {object} data instantiation data as received from the backend\n */\nconst fillTable = (data) => {\n    let allRows = [];\n    let rowCounter = 0;\n    for (let row of data) {\n        let thisRow = {id: ++rowCounter};\n        for (let thisVar of row.randomvars) {\n            thisRow[`random_${thisVar.name}`] = thisVar.value;\n        }\n        for (let thisVar of row.globalvars) {\n            thisRow[`global_${thisVar.name}`] = thisVar.value;\n        }\n        let partCounter = 0;\n        for (let thisPart of row.parts) {\n            for (let thisVar of thisPart) {\n                thisRow[`part_${partCounter}_${thisVar.name}`] = thisVar.value;\n            }\n            partCounter++;\n        }\n        allRows.push(thisRow);\n    }\n\n    Tabulator.findTable(\"#varsdata_display\")[0].setData(allRows);\n};\n\n/**\n * Send the definition of random variables, global variables and parts' local variables\n * to the backend for instantiation. This will generate a certain number of rows, based\n * on the number the user has selected in the corresponding dropdown field. Once the\n * AJAX requeset is completed, the data will be forwarded to {@link prepareTableColumns}.\n */\nconst instantiate = async() => {\n    let howMany = document.getElementById('id_numdataset').value;\n    let localvars = [];\n    let answers = [];\n    for (let i = 0; i < numberOfParts; i++) {\n        localvars[i] = document.getElementById(`id_vars1_${i}`).value;\n        answers[i] = document.getElementById(`id_answer_${i}`).value;\n    }\n    let pendingPromise = new Pending('qtype_formulas/instantiate');\n    try {\n        let response = await fetchMany([{\n            methodname: 'qtype_formulas_instantiate',\n            args: {\n                n: howMany,\n                randomvars: document.getElementById('id_varsrandom').value,\n                globalvars: document.getElementById('id_varsglobal').value,\n                localvars: localvars,\n                answers: answers\n            }\n        }])[0];\n        if (response.status == 'error') {\n            let str = await String.get_string('previewerror', 'qtype_formulas');\n            document.getElementById('qtextpreview_display').innerHTML = `${str}<br>${response.message}`;\n        } else {\n            document.getElementById('qtextpreview_display').innerHTML = '';\n            prepareTableColumns(response.data);\n        }\n    } catch (err) {\n        Notification.exception(err);\n    }\n    pendingPromise.resolve();\n};\n\n/**\n * Event handler for the global variables definition. The function will send the text to\n * the backend and try to evaluate it (together with the random variables, because global\n * variables can be based on random variables). If there is an error, it will be shown\n * in the form via {@link showOrClearValidationError}.\n *\n * @param {Event} evt Event object\n */\nconst validateGlobalvars = async(evt) => {\n    // We don't validate an empty field. But if there is an error from earlier validation,\n    // we must make sure it is removed.\n    if (evt.target.value === '') {\n        showOrClearValidationError(evt.target.id, '');\n        return;\n    }\n    let pendingPromise = new Pending('qtype_formulas/validateglobal');\n    try {\n        let validationResult = await fetchMany([{\n            methodname: 'qtype_formulas_check_random_global_vars',\n            args: {\n                randomvars: document.getElementById('id_varsrandom').value,\n                globalvars: evt.target.value\n            },\n        }])[0];\n        showOrClearValidationError(evt.target.id, validationResult);\n    } catch (err) {\n        Notification.exception(err);\n    }\n    pendingPromise.resolve();\n};\n\n/**\n * Event handler for the random variables definition. The function will send the text to\n * the backend which tries to parse it and instantiate the variables. If there is an error,\n * it will be shown in the form via {@link showOrClearValidationError}.\n *\n * @param {Event} evt Event object\n */\nconst validateRandomvars = async(evt) => {\n    // We don't validate an empty field. But if there is an error from earlier validation,\n    // we must make sure it is removed.\n    if (evt.target.value === '') {\n        showOrClearValidationError(evt.target.id, '');\n        return;\n    }\n    let pendingPromise = new Pending('qtype_formulas/validaterandom');\n    try {\n        let validationResult = await fetchMany([{\n            methodname: 'qtype_formulas_check_random_global_vars',\n            args: {\n                randomvars: evt.target.value\n            },\n        }])[0];\n        showOrClearValidationError(evt.target.id, validationResult);\n    } catch (err) {\n        Notification.exception(err);\n    }\n    pendingPromise.resolve();\n};\n\nconst validateLocalvars = async(part) => {\n    let target = document.getElementById(`id_vars1_${part}`);\n    // We don't validate an empty field. But if there is an error from earlier validation,\n    // we must make sure it is removed.\n    if (target.value === '') {\n        showOrClearValidationError(target.id, '');\n        return;\n    }\n    let pendingPromise = new Pending('qtype_formulas/validatelocal');\n    try {\n        let validationResult = await fetchMany([{\n            methodname: 'qtype_formulas_check_local_vars',\n            args: {\n                randomvars: document.getElementById('id_varsrandom').value,\n                globalvars: document.getElementById('id_varsglobal').value,\n                localvars: target.value\n            }\n        }])[0];\n        showOrClearValidationError(target.id, validationResult);\n    } catch (err) {\n        Notification.exception(err);\n    }\n    pendingPromise.resolve();\n};\n\n/**\n * Show a validation error below the corresponding form field and set the field\n * as invalid. Or remove message and marking, if there is no error anymore.\n *\n * @param {string} fieldID id of the form field to which the error belongs\n * @param {string} message error message or empty string, if error is to be removed\n */\nconst showOrClearValidationError = (fieldID, message) => {\n    let field = document.getElementById(fieldID);\n    let annotation = document.getElementById(fieldID.replace(/^id_(.*)$/, 'id_error_$1'));\n    if (message === '') {\n        annotation.innerText = '';\n        field.classList.remove('is-invalid');\n    } else {\n        annotation.innerText = message;\n        field.classList.add('is-invalid');\n        field.focus();\n    }\n};\n\n/**\n * The textfields containing the grading criterion might be disabled. However, as disabled elements\n * do not submit their value, they have to be enabled before submitting the form.\n */\nconst reenableCriterionTextfields = () => {\n    for (let i = 0; i < numberOfParts; i++) {\n        document.getElementById(`id_correctness_${i}`).disabled = false;\n    }\n};\n\n/**\n * Handle change event for the elements that allow simplified entry of the grading criterion.\n * On each modification, the current criterion is propagated to the (hidden) textbox,\n * that will be used to store the criterion in the database upon submission of the form.\n * @param {number} partNumber number of the part\n */\nconst handleSimpleCriterionChanges = (partNumber) => {\n    let textbox = document.getElementById(`id_correctness_${partNumber}`);\n    textbox.value = convertSimpleCriterionToText(partNumber);\n};\n\n/**\n * Parse the tolerance value into a number and put the value back into the textfield.\n * This allows for immediate simplification and some validation; invalid numbers will be replaced by 0.\n * @param {Event} event Event containing the textfield to be normalized\n */\nconst normalizeTolerance = (event) => {\n    let field = event.target;\n    let tolerance = parseFloat(field.value);\n\n    if (isNaN(tolerance) || !isFinite(tolerance)) {\n        tolerance = 0;\n    }\n\n    field.value = tolerance;\n};\n\n/**\n * Switch between simplified and normal entry mode for the grading criterion.\n * @param {number} partNumber number of the part\n */\nconst handleGradingCriterionModeSwitcher = (partNumber) => {\n    let checkbox = document.getElementById(`id_correctness_simple_mode_${partNumber}`);\n\n    let criterionTextfield = document.getElementById(`id_correctness_${partNumber}`);\n\n    // If not checked anymore, activate expert mode --> convert settings to string and set textfield.\n    if (!checkbox.checked) {\n        criterionTextfield.value = convertSimpleCriterionToText(partNumber);\n        return;\n    }\n\n    // Activate simple mode. If input field is empty, use default value.\n    if (criterionTextfield.value.trim() == '') {\n        criterionTextfield.value = defaultCorrectness;\n    }\n\n    let simpleCriterion = convertTextCriterionToSimple(partNumber);\n    document.getElementById(`id_correctness_simple_type_${partNumber}`).value = simpleCriterion.type;\n    document.getElementById(`id_correctness_simple_comp_${partNumber}`).value = simpleCriterion.comparison;\n    document.getElementById(`id_correctness_simple_tol_${partNumber}`).value = simpleCriterion.tolerance;\n};\n\n/**\n * Convert the simple grading criterion into the corresponding text.\n * @param {number} partNumber number of the part\n * @returns {string} text form of the grading criterion\n */\nconst convertSimpleCriterionToText = (partNumber) => {\n    let typeElement = document.getElementById(`id_correctness_simple_type_${partNumber}`);\n    let comparisonElement = document.getElementById(`id_correctness_simple_comp_${partNumber}`);\n    let toleranceElement = document.getElementById(`id_correctness_simple_tol_${partNumber}`);\n\n    return ['_relerr', '_err'][typeElement.value] + ' '\n        + comparisonElement.options[comparisonElement.value].innerText + ' '\n        + parseFloat(toleranceElement.value);\n};\n\n/**\n * Convert the grading criterion into the simplified form.\n * @param {number} partNumber number of the part\n * @returns {object} criterion the simplified grading criterion\n * @returns {number} criterion.type the type of error (relative or absolute)\n * @returns {number} criterion.comparison the comparison (== or <)\n * @returns {number} criteron.tolerance the tolerance value\n * @throws {TypeError} throws if the value cannot be converted\n */\nconst convertTextCriterionToSimple = (partNumber) => {\n    // Split input into its parts (type, comparison, tolerance).\n    let criterionParts = document.getElementById(`id_correctness_${partNumber}`).value.split(/\\s*(==|<)\\s*/);\n\n    // This should not happen, but it might be better to check anyway.\n    if (criterionParts.length != 3 || !criterionParts[0].match(/^\\s*_(rel)?err\\s*$/)) {\n        throw new TypeError('The given grading criterion cannot be shown in simple mode.');\n    }\n\n    return {\n        'type': ['_relerr', '_err'].indexOf(criterionParts[0]),\n        'comparison': ['==', '<'].indexOf(criterionParts[1]),\n        'tolerance': parseFloat(criterionParts[2])\n    };\n};\n\n/**\n * Check whether the current grading criterion can be converted into the simplified form.\n * If not, disable the checkbox that would allow switching to simple mode.\n * If yes, enable sais checkbox.\n * If the text box is empty, conversion is possible using the default value.\n * @param {number} partNumber number of the part\n */\nconst blockModeSwitcherIfNeeded = (partNumber) => {\n    let criterion = document.getElementById(`id_correctness_${partNumber}`).value.trim();\n    let modeCheckbox = document.getElementById(`id_correctness_simple_mode_${partNumber}`);\n    // If textfield is empty, allow conversion to easy mode\n    if (criterion == '') {\n        modeCheckbox.disabled = false;\n        return;\n    }\n\n    // Value must have exactly three parts: type + comparison + tolerance (number).\n    let criterionParts = criterion.split(/\\s*(==|<)\\s*/);\n    if (criterionParts.length != 3) {\n        modeCheckbox.disabled = true;\n        return;\n    }\n\n    // Type must be _relerr or _err.\n    if (!criterionParts[0].match(/^\\s*_(rel)?err\\s*$/)) {\n        modeCheckbox.disabled = true;\n        return;\n    }\n\n    // Comparison must be == or <.\n    if (!criterionParts[1].match(/\\s*(==|<)\\s*$/)) {\n        modeCheckbox.disabled = true;\n        return;\n    }\n\n    // Tolerance must be a number.\n    let tolerance = parseFloat(criterionParts[2]);\n    // As parseFloat ignores trailing characters, we check for that separately;\n    // we just don't want the tolerance number to contain obviously invalid characters.\n    if (isNaN(tolerance) || !isFinite(tolerance) || criterionParts[2].match(/[^-+0-9.e]/)) {\n        modeCheckbox.disabled = true;\n        return;\n    }\n\n    modeCheckbox.disabled = false;\n};\n\nexport default {init};\n"],"names":["defaultCorrectness","numberOfParts","init","defCorrectness","document","querySelectorAll","length","extendTabulator","initTable","i","textfield","getElementById","form","addEventListener","reenableCriterionTextfields","blockModeSwitcherIfNeeded","bind","checkbox","handleGradingCriterionModeSwitcher","dispatchEvent","Event","disabled","classList","contains","checked","element","handleSimpleCriterionChanges","normalizeTolerance","variableFields","field","handler","validateRandomvars","validateGlobalvars","push","validateLocalvars","instantiate","extendModule","values","count","min","Infinity","max","sum","value","parseFloat","Math","isNaN","toFixed","Tabulator","selectable","movableColumns","pagination","paginationSize","paginationButtonCount","columns","title","langs","on","previewQuestionWithDataset","quoteNonNumericValue","startsWith","quotedElements","substring","split","join","fetchTextFromEditor","id","window","tinyMCE","get","getContent","row","getElement","data","getData","questionvars","partvars","Array","fill","varname","match","replace","index","parseInt","parttexts","pendingPromise","Pending","methodname","args","questiontext","globalvars","renderedTexts","showRenderedQuestionAndParts","Notification","exception","resolve","div","innerHTML","question","parts","text","MathJax","version","typesetPromise","Hub","Queue","triggerMathJax","prepareTableColumns","firstRow","calcOptions","bottomCalc","bottomCalcFormatter","cell","getValue","columnDescription","randomColumns","randomvars","column","name","globalColumns","partColumns","partIndex","part","thisPartsColumns","vars","findTable","setColumns","fillTable","style","display","allRows","rowCounter","thisRow","thisVar","partCounter","setData","howMany","localvars","answers","n","response","status","String","get_string","str","message","evt","target","showOrClearValidationError","validationResult","fieldID","annotation","innerText","remove","add","focus","partNumber","convertSimpleCriterionToText","event","tolerance","isFinite","criterionTextfield","trim","simpleCriterion","convertTextCriterionToSimple","type","comparison","typeElement","comparisonElement","toleranceElement","options","criterionParts","TypeError","indexOf","criterion","modeCheckbox"],"mappings":"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"}